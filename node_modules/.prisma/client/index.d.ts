import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
  Sql,
  Decimal,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }
export { Decimal }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw, Sql }

/**
 * Prisma Client JS version: 2.10.2
 * Query Engine version: 7d0087eadc7265e12d4b8d8c3516b02c4c965111
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'findFirst'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$queryRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): AccountDelegate;

  /**
   * `prisma.chunk`: Exposes CRUD operations for the **Chunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chunks
    * const chunks = await prisma.chunk.findMany()
    * ```
    */
  get chunk(): ChunkDelegate;

  /**
   * `prisma.contributorAttribute`: Exposes CRUD operations for the **ContributorAttribute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContributorAttributes
    * const contributorAttributes = await prisma.contributorAttribute.findMany()
    * ```
    */
  get contributorAttribute(): ContributorAttributeDelegate;

  /**
   * `prisma.contributorAttributeValue`: Exposes CRUD operations for the **ContributorAttributeValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContributorAttributeValues
    * const contributorAttributeValues = await prisma.contributorAttributeValue.findMany()
    * ```
    */
  get contributorAttributeValue(): ContributorAttributeValueDelegate;

  /**
   * `prisma.discovery`: Exposes CRUD operations for the **Discovery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discoveries
    * const discoveries = await prisma.discovery.findMany()
    * ```
    */
  get discovery(): DiscoveryDelegate;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): MessageDelegate;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): OrganizationDelegate;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): PersonDelegate;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): ProjectDelegate;

  /**
   * `prisma.subMessage`: Exposes CRUD operations for the **SubMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubMessages
    * const subMessages = await prisma.subMessage.findMany()
    * ```
    */
  get subMessage(): SubMessageDelegate;

  /**
   * `prisma.textSelection`: Exposes CRUD operations for the **TextSelection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TextSelections
    * const textSelections = await prisma.textSelection.findMany()
    * ```
    */
  get textSelection(): TextSelectionDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const AccountDistinctFieldEnum: {
  id: 'id',
  username: 'username',
  hashedPassword: 'hashedPassword',
  personId: 'personId',
  projectId: 'projectId',
  type: 'type'
};

export declare type AccountDistinctFieldEnum = (typeof AccountDistinctFieldEnum)[keyof typeof AccountDistinctFieldEnum]


export declare const ChunkDistinctFieldEnum: {
  projectId: 'projectId',
  id: 'id',
  messageId: 'messageId',
  discoveryId: 'discoveryId'
};

export declare type ChunkDistinctFieldEnum = (typeof ChunkDistinctFieldEnum)[keyof typeof ChunkDistinctFieldEnum]


export declare const ContributorAttributeDistinctFieldEnum: {
  projectId: 'projectId',
  id: 'id',
  appliesTo: 'appliesTo',
  name: 'name',
  type: 'type'
};

export declare type ContributorAttributeDistinctFieldEnum = (typeof ContributorAttributeDistinctFieldEnum)[keyof typeof ContributorAttributeDistinctFieldEnum]


export declare const ContributorAttributeValueDistinctFieldEnum: {
  id: 'id',
  contributorAttributeId: 'contributorAttributeId',
  contributorAttributeType: 'contributorAttributeType',
  personId: 'personId',
  organizationId: 'organizationId',
  valuetext: 'valuetext'
};

export declare type ContributorAttributeValueDistinctFieldEnum = (typeof ContributorAttributeValueDistinctFieldEnum)[keyof typeof ContributorAttributeValueDistinctFieldEnum]


export declare const DiscoveryDistinctFieldEnum: {
  projectId: 'projectId',
  id: 'id',
  title: 'title',
  description: 'description'
};

export declare type DiscoveryDistinctFieldEnum = (typeof DiscoveryDistinctFieldEnum)[keyof typeof DiscoveryDistinctFieldEnum]


export declare const MessageDistinctFieldEnum: {
  projectId: 'projectId',
  id: 'id',
  requesterId: 'requesterId',
  submitterId: 'submitterId',
  clientId: 'clientId',
  title: 'title',
  content: 'content'
};

export declare type MessageDistinctFieldEnum = (typeof MessageDistinctFieldEnum)[keyof typeof MessageDistinctFieldEnum]


export declare const OrganizationDistinctFieldEnum: {
  projectId: 'projectId',
  id: 'id',
  name: 'name'
};

export declare type OrganizationDistinctFieldEnum = (typeof OrganizationDistinctFieldEnum)[keyof typeof OrganizationDistinctFieldEnum]


export declare const PersonDistinctFieldEnum: {
  projectId: 'projectId',
  id: 'id',
  name: 'name',
  email: 'email',
  organizationId: 'organizationId'
};

export declare type PersonDistinctFieldEnum = (typeof PersonDistinctFieldEnum)[keyof typeof PersonDistinctFieldEnum]


export declare const ProjectDistinctFieldEnum: {
  id: 'id',
  name: 'name'
};

export declare type ProjectDistinctFieldEnum = (typeof ProjectDistinctFieldEnum)[keyof typeof ProjectDistinctFieldEnum]


export declare const SubMessageDistinctFieldEnum: {
  id: 'id',
  submitterId: 'submitterId',
  content: 'content',
  messageId: 'messageId'
};

export declare type SubMessageDistinctFieldEnum = (typeof SubMessageDistinctFieldEnum)[keyof typeof SubMessageDistinctFieldEnum]


export declare const TextSelectionDistinctFieldEnum: {
  id: 'id',
  offsetstart: 'offsetstart',
  length: 'length',
  submessagenumber: 'submessagenumber',
  content: 'content',
  chunkId: 'chunkId'
};

export declare type TextSelectionDistinctFieldEnum = (typeof TextSelectionDistinctFieldEnum)[keyof typeof TextSelectionDistinctFieldEnum]


export declare const ACCOUNT_TYPE: {
  MAIN_ADMIN: 'MAIN_ADMIN',
  ADMIN: 'ADMIN',
  VIEWER: 'VIEWER'
};

export declare type ACCOUNT_TYPE = (typeof ACCOUNT_TYPE)[keyof typeof ACCOUNT_TYPE]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export declare const ENTITY_TYPE: {
  Person: 'Person',
  Organization: 'Organization'
};

export declare type ENTITY_TYPE = (typeof ENTITY_TYPE)[keyof typeof ENTITY_TYPE]


export declare const CONTRIBUTOR_ATTRIBUTE_TYPE: {
  TEXT: 'TEXT',
  NUMERIC: 'NUMERIC',
  FINANCIAL: 'FINANCIAL',
  DECIMAL: 'DECIMAL',
  RATING: 'RATING',
  BOOLEAN: 'BOOLEAN',
  DATE: 'DATE',
  LIST: 'LIST',
  URL: 'URL'
};

export declare type CONTRIBUTOR_ATTRIBUTE_TYPE = (typeof CONTRIBUTOR_ATTRIBUTE_TYPE)[keyof typeof CONTRIBUTOR_ATTRIBUTE_TYPE]


export declare const QueryMode: {
  default: 'default',
  insensitive: 'insensitive'
};

export declare type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]



/**
 * Model Account
 */

export type Account = {
  id: number
  username: string
  hashedPassword: string
  personId: number
  projectId: number
  type: ACCOUNT_TYPE | null
}


export type AggregateAccount = {
  count: number
  avg: AccountAvgAggregateOutputType | null
  sum: AccountSumAggregateOutputType | null
  min: AccountMinAggregateOutputType | null
  max: AccountMaxAggregateOutputType | null
}

export type AccountAvgAggregateOutputType = {
  id: number
  personId: number
  projectId: number
}

export type AccountSumAggregateOutputType = {
  id: number
  personId: number
  projectId: number
}

export type AccountMinAggregateOutputType = {
  id: number
  personId: number
  projectId: number
}

export type AccountMaxAggregateOutputType = {
  id: number
  personId: number
  projectId: number
}


export type AccountAvgAggregateInputType = {
  id?: true
  personId?: true
  projectId?: true
}

export type AccountSumAggregateInputType = {
  id?: true
  personId?: true
  projectId?: true
}

export type AccountMinAggregateInputType = {
  id?: true
  personId?: true
  projectId?: true
}

export type AccountMaxAggregateInputType = {
  id?: true
  personId?: true
  projectId?: true
}

export type AggregateAccountArgs = {
  where?: AccountWhereInput
  orderBy?: Enumerable<AccountOrderByInput> | AccountOrderByInput
  cursor?: AccountWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AccountDistinctFieldEnum>
  count?: true
  avg?: AccountAvgAggregateInputType
  sum?: AccountSumAggregateInputType
  min?: AccountMinAggregateInputType
  max?: AccountMaxAggregateInputType
}

export type GetAccountAggregateType<T extends AggregateAccountArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetAccountAggregateScalarType<T[P]>
}

export type GetAccountAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof AccountAvgAggregateOutputType ? AccountAvgAggregateOutputType[P] : never
}
    
    

export type AccountSelect = {
  id?: boolean
  username?: boolean
  hashedPassword?: boolean
  personId?: boolean
  projectId?: boolean
  type?: boolean
  person?: boolean | PersonArgs
  project?: boolean | ProjectArgs
}

export type AccountInclude = {
  person?: boolean | PersonArgs
  project?: boolean | ProjectArgs
}

export type AccountGetPayload<
  S extends boolean | null | undefined | AccountArgs,
  U = keyof S
> = S extends true
  ? Account
  : S extends undefined
  ? never
  : S extends AccountArgs | FindManyAccountArgs
  ? 'include' extends U
    ? Account  & {
      [P in TrueKeys<S['include']>]:
      P extends 'person'
      ? PersonGetPayload<S['include'][P]> :
      P extends 'project'
      ? ProjectGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Account ? Account[P]
: 
      P extends 'person'
      ? PersonGetPayload<S['select'][P]> :
      P extends 'project'
      ? ProjectGetPayload<S['select'][P]> : never
    }
  : Account
: Account


export interface AccountDelegate {
  /**
   * Find zero or one Account that matches the filter.
   * @param {FindOneAccountArgs} args - Arguments to find a Account
   * @example
   * // Get one Account
   * const account = await prisma.account.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAccountArgs>(
    args: Subset<T, FindOneAccountArgs>
  ): CheckSelect<T, Prisma__AccountClient<Account | null>, Prisma__AccountClient<AccountGetPayload<T> | null>>
  /**
   * Find the first Account that matches the filter.
   * @param {FindFirstAccountArgs} args - Arguments to find a Account
   * @example
   * // Get one Account
   * const account = await prisma.account.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstAccountArgs>(
    args?: Subset<T, FindFirstAccountArgs>
  ): CheckSelect<T, Prisma__AccountClient<Account | null>, Prisma__AccountClient<AccountGetPayload<T> | null>>
  /**
   * Find zero or more Accounts that matches the filter.
   * @param {FindManyAccountArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Accounts
   * const accounts = await prisma.account.findMany()
   * 
   * // Get first 10 Accounts
   * const accounts = await prisma.account.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAccountArgs>(
    args?: Subset<T, FindManyAccountArgs>
  ): CheckSelect<T, Promise<Array<Account>>, Promise<Array<AccountGetPayload<T>>>>
  /**
   * Create a Account.
   * @param {AccountCreateArgs} args - Arguments to create a Account.
   * @example
   * // Create one Account
   * const Account = await prisma.account.create({
   *   data: {
   *     // ... data to create a Account
   *   }
   * })
   * 
  **/
  create<T extends AccountCreateArgs>(
    args: Subset<T, AccountCreateArgs>
  ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>
  /**
   * Delete a Account.
   * @param {AccountDeleteArgs} args - Arguments to delete one Account.
   * @example
   * // Delete one Account
   * const Account = await prisma.account.delete({
   *   where: {
   *     // ... filter to delete one Account
   *   }
   * })
   * 
  **/
  delete<T extends AccountDeleteArgs>(
    args: Subset<T, AccountDeleteArgs>
  ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>
  /**
   * Update one Account.
   * @param {AccountUpdateArgs} args - Arguments to update one Account.
   * @example
   * // Update one Account
   * const account = await prisma.account.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AccountUpdateArgs>(
    args: Subset<T, AccountUpdateArgs>
  ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>
  /**
   * Delete zero or more Accounts.
   * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
   * @example
   * // Delete a few Accounts
   * const { count } = await prisma.account.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AccountDeleteManyArgs>(
    args: Subset<T, AccountDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Accounts.
   * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Accounts
   * const account = await prisma.account.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AccountUpdateManyArgs>(
    args: Subset<T, AccountUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Account.
   * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
   * @example
   * // Update or create a Account
   * const account = await prisma.account.upsert({
   *   create: {
   *     // ... data to create a Account
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Account we want to update
   *   }
   * })
  **/
  upsert<T extends AccountUpsertArgs>(
    args: Subset<T, AccountUpsertArgs>
  ): CheckSelect<T, Prisma__AccountClient<Account>, Prisma__AccountClient<AccountGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAccountArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAccountArgs>(args: Subset<T, AggregateAccountArgs>): Promise<GetAccountAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Account.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AccountClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>;

  project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Account findOne
 */
export type FindOneAccountArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * Filter, which Account to fetch.
  **/
  where: AccountWhereUniqueInput
}


/**
 * Account findFirst
 */
export type FindFirstAccountArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * Filter, which Account to fetch.
  **/
  where?: AccountWhereInput
  orderBy?: Enumerable<AccountOrderByInput> | AccountOrderByInput
  cursor?: AccountWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AccountDistinctFieldEnum>
}


/**
 * Account findMany
 */
export type FindManyAccountArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * Filter, which Accounts to fetch.
  **/
  where?: AccountWhereInput
  /**
   * Determine the order of the Accounts to fetch.
  **/
  orderBy?: Enumerable<AccountOrderByInput> | AccountOrderByInput
  /**
   * Sets the position for listing Accounts.
  **/
  cursor?: AccountWhereUniqueInput
  /**
   * The number of Accounts to fetch. If negative number, it will take Accounts before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Accounts.
  **/
  skip?: number
  distinct?: Enumerable<AccountDistinctFieldEnum>
}


/**
 * Account create
 */
export type AccountCreateArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * The data needed to create a Account.
  **/
  data: AccountCreateInput
}


/**
 * Account update
 */
export type AccountUpdateArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * The data needed to update a Account.
  **/
  data: AccountUpdateInput
  /**
   * Choose, which Account to update.
  **/
  where: AccountWhereUniqueInput
}


/**
 * Account updateMany
 */
export type AccountUpdateManyArgs = {
  data: AccountUpdateManyMutationInput
  where?: AccountWhereInput
}


/**
 * Account upsert
 */
export type AccountUpsertArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * The filter to search for the Account to update in case it exists.
  **/
  where: AccountWhereUniqueInput
  /**
   * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
  **/
  create: AccountCreateInput
  /**
   * In case the Account was found with the provided `where` argument, update it with this data.
  **/
  update: AccountUpdateInput
}


/**
 * Account delete
 */
export type AccountDeleteArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
  /**
   * Filter which Account to delete.
  **/
  where: AccountWhereUniqueInput
}


/**
 * Account deleteMany
 */
export type AccountDeleteManyArgs = {
  where?: AccountWhereInput
}


/**
 * Account without action
 */
export type AccountArgs = {
  /**
   * Select specific fields to fetch from the Account
  **/
  select?: AccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AccountInclude | null
}



/**
 * Model Chunk
 */

export type Chunk = {
  projectId: number
  id: number
  messageId: number
  discoveryId: number
}


export type AggregateChunk = {
  count: number
  avg: ChunkAvgAggregateOutputType | null
  sum: ChunkSumAggregateOutputType | null
  min: ChunkMinAggregateOutputType | null
  max: ChunkMaxAggregateOutputType | null
}

export type ChunkAvgAggregateOutputType = {
  projectId: number
  id: number
  messageId: number
  discoveryId: number
}

export type ChunkSumAggregateOutputType = {
  projectId: number
  id: number
  messageId: number
  discoveryId: number
}

export type ChunkMinAggregateOutputType = {
  projectId: number
  id: number
  messageId: number
  discoveryId: number
}

export type ChunkMaxAggregateOutputType = {
  projectId: number
  id: number
  messageId: number
  discoveryId: number
}


export type ChunkAvgAggregateInputType = {
  projectId?: true
  id?: true
  messageId?: true
  discoveryId?: true
}

export type ChunkSumAggregateInputType = {
  projectId?: true
  id?: true
  messageId?: true
  discoveryId?: true
}

export type ChunkMinAggregateInputType = {
  projectId?: true
  id?: true
  messageId?: true
  discoveryId?: true
}

export type ChunkMaxAggregateInputType = {
  projectId?: true
  id?: true
  messageId?: true
  discoveryId?: true
}

export type AggregateChunkArgs = {
  where?: ChunkWhereInput
  orderBy?: Enumerable<ChunkOrderByInput> | ChunkOrderByInput
  cursor?: ChunkWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ChunkDistinctFieldEnum>
  count?: true
  avg?: ChunkAvgAggregateInputType
  sum?: ChunkSumAggregateInputType
  min?: ChunkMinAggregateInputType
  max?: ChunkMaxAggregateInputType
}

export type GetChunkAggregateType<T extends AggregateChunkArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetChunkAggregateScalarType<T[P]>
}

export type GetChunkAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ChunkAvgAggregateOutputType ? ChunkAvgAggregateOutputType[P] : never
}
    
    

export type ChunkSelect = {
  projectId?: boolean
  id?: boolean
  messageId?: boolean
  discoveryId?: boolean
  discovery?: boolean | DiscoveryArgs
  message?: boolean | MessageArgs
  project?: boolean | ProjectArgs
  textSelections?: boolean | FindManyTextSelectionArgs
}

export type ChunkInclude = {
  discovery?: boolean | DiscoveryArgs
  message?: boolean | MessageArgs
  project?: boolean | ProjectArgs
  textSelections?: boolean | FindManyTextSelectionArgs
}

export type ChunkGetPayload<
  S extends boolean | null | undefined | ChunkArgs,
  U = keyof S
> = S extends true
  ? Chunk
  : S extends undefined
  ? never
  : S extends ChunkArgs | FindManyChunkArgs
  ? 'include' extends U
    ? Chunk  & {
      [P in TrueKeys<S['include']>]:
      P extends 'discovery'
      ? DiscoveryGetPayload<S['include'][P]> :
      P extends 'message'
      ? MessageGetPayload<S['include'][P]> :
      P extends 'project'
      ? ProjectGetPayload<S['include'][P]> :
      P extends 'textSelections'
      ? Array<TextSelectionGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Chunk ? Chunk[P]
: 
      P extends 'discovery'
      ? DiscoveryGetPayload<S['select'][P]> :
      P extends 'message'
      ? MessageGetPayload<S['select'][P]> :
      P extends 'project'
      ? ProjectGetPayload<S['select'][P]> :
      P extends 'textSelections'
      ? Array<TextSelectionGetPayload<S['select'][P]>> : never
    }
  : Chunk
: Chunk


export interface ChunkDelegate {
  /**
   * Find zero or one Chunk that matches the filter.
   * @param {FindOneChunkArgs} args - Arguments to find a Chunk
   * @example
   * // Get one Chunk
   * const chunk = await prisma.chunk.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneChunkArgs>(
    args: Subset<T, FindOneChunkArgs>
  ): CheckSelect<T, Prisma__ChunkClient<Chunk | null>, Prisma__ChunkClient<ChunkGetPayload<T> | null>>
  /**
   * Find the first Chunk that matches the filter.
   * @param {FindFirstChunkArgs} args - Arguments to find a Chunk
   * @example
   * // Get one Chunk
   * const chunk = await prisma.chunk.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstChunkArgs>(
    args?: Subset<T, FindFirstChunkArgs>
  ): CheckSelect<T, Prisma__ChunkClient<Chunk | null>, Prisma__ChunkClient<ChunkGetPayload<T> | null>>
  /**
   * Find zero or more Chunks that matches the filter.
   * @param {FindManyChunkArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Chunks
   * const chunks = await prisma.chunk.findMany()
   * 
   * // Get first 10 Chunks
   * const chunks = await prisma.chunk.findMany({ take: 10 })
   * 
   * // Only select the `projectId`
   * const chunkWithProjectIdOnly = await prisma.chunk.findMany({ select: { projectId: true } })
   * 
  **/
  findMany<T extends FindManyChunkArgs>(
    args?: Subset<T, FindManyChunkArgs>
  ): CheckSelect<T, Promise<Array<Chunk>>, Promise<Array<ChunkGetPayload<T>>>>
  /**
   * Create a Chunk.
   * @param {ChunkCreateArgs} args - Arguments to create a Chunk.
   * @example
   * // Create one Chunk
   * const Chunk = await prisma.chunk.create({
   *   data: {
   *     // ... data to create a Chunk
   *   }
   * })
   * 
  **/
  create<T extends ChunkCreateArgs>(
    args: Subset<T, ChunkCreateArgs>
  ): CheckSelect<T, Prisma__ChunkClient<Chunk>, Prisma__ChunkClient<ChunkGetPayload<T>>>
  /**
   * Delete a Chunk.
   * @param {ChunkDeleteArgs} args - Arguments to delete one Chunk.
   * @example
   * // Delete one Chunk
   * const Chunk = await prisma.chunk.delete({
   *   where: {
   *     // ... filter to delete one Chunk
   *   }
   * })
   * 
  **/
  delete<T extends ChunkDeleteArgs>(
    args: Subset<T, ChunkDeleteArgs>
  ): CheckSelect<T, Prisma__ChunkClient<Chunk>, Prisma__ChunkClient<ChunkGetPayload<T>>>
  /**
   * Update one Chunk.
   * @param {ChunkUpdateArgs} args - Arguments to update one Chunk.
   * @example
   * // Update one Chunk
   * const chunk = await prisma.chunk.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ChunkUpdateArgs>(
    args: Subset<T, ChunkUpdateArgs>
  ): CheckSelect<T, Prisma__ChunkClient<Chunk>, Prisma__ChunkClient<ChunkGetPayload<T>>>
  /**
   * Delete zero or more Chunks.
   * @param {ChunkDeleteManyArgs} args - Arguments to filter Chunks to delete.
   * @example
   * // Delete a few Chunks
   * const { count } = await prisma.chunk.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ChunkDeleteManyArgs>(
    args: Subset<T, ChunkDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Chunks.
   * @param {ChunkUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Chunks
   * const chunk = await prisma.chunk.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ChunkUpdateManyArgs>(
    args: Subset<T, ChunkUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Chunk.
   * @param {ChunkUpsertArgs} args - Arguments to update or create a Chunk.
   * @example
   * // Update or create a Chunk
   * const chunk = await prisma.chunk.upsert({
   *   create: {
   *     // ... data to create a Chunk
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Chunk we want to update
   *   }
   * })
  **/
  upsert<T extends ChunkUpsertArgs>(
    args: Subset<T, ChunkUpsertArgs>
  ): CheckSelect<T, Prisma__ChunkClient<Chunk>, Prisma__ChunkClient<ChunkGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyChunkArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateChunkArgs>(args: Subset<T, AggregateChunkArgs>): Promise<GetChunkAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Chunk.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ChunkClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  discovery<T extends DiscoveryArgs = {}>(args?: Subset<T, DiscoveryArgs>): CheckSelect<T, Prisma__DiscoveryClient<Discovery | null>, Prisma__DiscoveryClient<DiscoveryGetPayload<T> | null>>;

  message<T extends MessageArgs = {}>(args?: Subset<T, MessageArgs>): CheckSelect<T, Prisma__MessageClient<Message | null>, Prisma__MessageClient<MessageGetPayload<T> | null>>;

  project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>;

  textSelections<T extends FindManyTextSelectionArgs = {}>(args?: Subset<T, FindManyTextSelectionArgs>): CheckSelect<T, Promise<Array<TextSelection>>, Promise<Array<TextSelectionGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Chunk findOne
 */
export type FindOneChunkArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
  /**
   * Filter, which Chunk to fetch.
  **/
  where: ChunkWhereUniqueInput
}


/**
 * Chunk findFirst
 */
export type FindFirstChunkArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
  /**
   * Filter, which Chunk to fetch.
  **/
  where?: ChunkWhereInput
  orderBy?: Enumerable<ChunkOrderByInput> | ChunkOrderByInput
  cursor?: ChunkWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ChunkDistinctFieldEnum>
}


/**
 * Chunk findMany
 */
export type FindManyChunkArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
  /**
   * Filter, which Chunks to fetch.
  **/
  where?: ChunkWhereInput
  /**
   * Determine the order of the Chunks to fetch.
  **/
  orderBy?: Enumerable<ChunkOrderByInput> | ChunkOrderByInput
  /**
   * Sets the position for listing Chunks.
  **/
  cursor?: ChunkWhereUniqueInput
  /**
   * The number of Chunks to fetch. If negative number, it will take Chunks before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Chunks.
  **/
  skip?: number
  distinct?: Enumerable<ChunkDistinctFieldEnum>
}


/**
 * Chunk create
 */
export type ChunkCreateArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
  /**
   * The data needed to create a Chunk.
  **/
  data: ChunkCreateInput
}


/**
 * Chunk update
 */
export type ChunkUpdateArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
  /**
   * The data needed to update a Chunk.
  **/
  data: ChunkUpdateInput
  /**
   * Choose, which Chunk to update.
  **/
  where: ChunkWhereUniqueInput
}


/**
 * Chunk updateMany
 */
export type ChunkUpdateManyArgs = {
  data: ChunkUpdateManyMutationInput
  where?: ChunkWhereInput
}


/**
 * Chunk upsert
 */
export type ChunkUpsertArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
  /**
   * The filter to search for the Chunk to update in case it exists.
  **/
  where: ChunkWhereUniqueInput
  /**
   * In case the Chunk found by the `where` argument doesn't exist, create a new Chunk with this data.
  **/
  create: ChunkCreateInput
  /**
   * In case the Chunk was found with the provided `where` argument, update it with this data.
  **/
  update: ChunkUpdateInput
}


/**
 * Chunk delete
 */
export type ChunkDeleteArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
  /**
   * Filter which Chunk to delete.
  **/
  where: ChunkWhereUniqueInput
}


/**
 * Chunk deleteMany
 */
export type ChunkDeleteManyArgs = {
  where?: ChunkWhereInput
}


/**
 * Chunk without action
 */
export type ChunkArgs = {
  /**
   * Select specific fields to fetch from the Chunk
  **/
  select?: ChunkSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ChunkInclude | null
}



/**
 * Model ContributorAttribute
 */

export type ContributorAttribute = {
  projectId: number
  id: number
  appliesTo: ENTITY_TYPE | null
  name: string
  type: CONTRIBUTOR_ATTRIBUTE_TYPE
}


export type AggregateContributorAttribute = {
  count: number
  avg: ContributorAttributeAvgAggregateOutputType | null
  sum: ContributorAttributeSumAggregateOutputType | null
  min: ContributorAttributeMinAggregateOutputType | null
  max: ContributorAttributeMaxAggregateOutputType | null
}

export type ContributorAttributeAvgAggregateOutputType = {
  projectId: number
  id: number
}

export type ContributorAttributeSumAggregateOutputType = {
  projectId: number
  id: number
}

export type ContributorAttributeMinAggregateOutputType = {
  projectId: number
  id: number
}

export type ContributorAttributeMaxAggregateOutputType = {
  projectId: number
  id: number
}


export type ContributorAttributeAvgAggregateInputType = {
  projectId?: true
  id?: true
}

export type ContributorAttributeSumAggregateInputType = {
  projectId?: true
  id?: true
}

export type ContributorAttributeMinAggregateInputType = {
  projectId?: true
  id?: true
}

export type ContributorAttributeMaxAggregateInputType = {
  projectId?: true
  id?: true
}

export type AggregateContributorAttributeArgs = {
  where?: ContributorAttributeWhereInput
  orderBy?: Enumerable<ContributorAttributeOrderByInput> | ContributorAttributeOrderByInput
  cursor?: ContributorAttributeWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ContributorAttributeDistinctFieldEnum>
  count?: true
  avg?: ContributorAttributeAvgAggregateInputType
  sum?: ContributorAttributeSumAggregateInputType
  min?: ContributorAttributeMinAggregateInputType
  max?: ContributorAttributeMaxAggregateInputType
}

export type GetContributorAttributeAggregateType<T extends AggregateContributorAttributeArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetContributorAttributeAggregateScalarType<T[P]>
}

export type GetContributorAttributeAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ContributorAttributeAvgAggregateOutputType ? ContributorAttributeAvgAggregateOutputType[P] : never
}
    
    

export type ContributorAttributeSelect = {
  projectId?: boolean
  id?: boolean
  appliesTo?: boolean
  name?: boolean
  type?: boolean
  project?: boolean | ProjectArgs
  contributorAttributeValues?: boolean | FindManyContributorAttributeValueArgs
}

export type ContributorAttributeInclude = {
  project?: boolean | ProjectArgs
  contributorAttributeValues?: boolean | FindManyContributorAttributeValueArgs
}

export type ContributorAttributeGetPayload<
  S extends boolean | null | undefined | ContributorAttributeArgs,
  U = keyof S
> = S extends true
  ? ContributorAttribute
  : S extends undefined
  ? never
  : S extends ContributorAttributeArgs | FindManyContributorAttributeArgs
  ? 'include' extends U
    ? ContributorAttribute  & {
      [P in TrueKeys<S['include']>]:
      P extends 'project'
      ? ProjectGetPayload<S['include'][P]> :
      P extends 'contributorAttributeValues'
      ? Array<ContributorAttributeValueGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof ContributorAttribute ? ContributorAttribute[P]
: 
      P extends 'project'
      ? ProjectGetPayload<S['select'][P]> :
      P extends 'contributorAttributeValues'
      ? Array<ContributorAttributeValueGetPayload<S['select'][P]>> : never
    }
  : ContributorAttribute
: ContributorAttribute


export interface ContributorAttributeDelegate {
  /**
   * Find zero or one ContributorAttribute that matches the filter.
   * @param {FindOneContributorAttributeArgs} args - Arguments to find a ContributorAttribute
   * @example
   * // Get one ContributorAttribute
   * const contributorAttribute = await prisma.contributorAttribute.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneContributorAttributeArgs>(
    args: Subset<T, FindOneContributorAttributeArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeClient<ContributorAttribute | null>, Prisma__ContributorAttributeClient<ContributorAttributeGetPayload<T> | null>>
  /**
   * Find the first ContributorAttribute that matches the filter.
   * @param {FindFirstContributorAttributeArgs} args - Arguments to find a ContributorAttribute
   * @example
   * // Get one ContributorAttribute
   * const contributorAttribute = await prisma.contributorAttribute.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstContributorAttributeArgs>(
    args?: Subset<T, FindFirstContributorAttributeArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeClient<ContributorAttribute | null>, Prisma__ContributorAttributeClient<ContributorAttributeGetPayload<T> | null>>
  /**
   * Find zero or more ContributorAttributes that matches the filter.
   * @param {FindManyContributorAttributeArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ContributorAttributes
   * const contributorAttributes = await prisma.contributorAttribute.findMany()
   * 
   * // Get first 10 ContributorAttributes
   * const contributorAttributes = await prisma.contributorAttribute.findMany({ take: 10 })
   * 
   * // Only select the `projectId`
   * const contributorAttributeWithProjectIdOnly = await prisma.contributorAttribute.findMany({ select: { projectId: true } })
   * 
  **/
  findMany<T extends FindManyContributorAttributeArgs>(
    args?: Subset<T, FindManyContributorAttributeArgs>
  ): CheckSelect<T, Promise<Array<ContributorAttribute>>, Promise<Array<ContributorAttributeGetPayload<T>>>>
  /**
   * Create a ContributorAttribute.
   * @param {ContributorAttributeCreateArgs} args - Arguments to create a ContributorAttribute.
   * @example
   * // Create one ContributorAttribute
   * const ContributorAttribute = await prisma.contributorAttribute.create({
   *   data: {
   *     // ... data to create a ContributorAttribute
   *   }
   * })
   * 
  **/
  create<T extends ContributorAttributeCreateArgs>(
    args: Subset<T, ContributorAttributeCreateArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeClient<ContributorAttribute>, Prisma__ContributorAttributeClient<ContributorAttributeGetPayload<T>>>
  /**
   * Delete a ContributorAttribute.
   * @param {ContributorAttributeDeleteArgs} args - Arguments to delete one ContributorAttribute.
   * @example
   * // Delete one ContributorAttribute
   * const ContributorAttribute = await prisma.contributorAttribute.delete({
   *   where: {
   *     // ... filter to delete one ContributorAttribute
   *   }
   * })
   * 
  **/
  delete<T extends ContributorAttributeDeleteArgs>(
    args: Subset<T, ContributorAttributeDeleteArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeClient<ContributorAttribute>, Prisma__ContributorAttributeClient<ContributorAttributeGetPayload<T>>>
  /**
   * Update one ContributorAttribute.
   * @param {ContributorAttributeUpdateArgs} args - Arguments to update one ContributorAttribute.
   * @example
   * // Update one ContributorAttribute
   * const contributorAttribute = await prisma.contributorAttribute.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ContributorAttributeUpdateArgs>(
    args: Subset<T, ContributorAttributeUpdateArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeClient<ContributorAttribute>, Prisma__ContributorAttributeClient<ContributorAttributeGetPayload<T>>>
  /**
   * Delete zero or more ContributorAttributes.
   * @param {ContributorAttributeDeleteManyArgs} args - Arguments to filter ContributorAttributes to delete.
   * @example
   * // Delete a few ContributorAttributes
   * const { count } = await prisma.contributorAttribute.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ContributorAttributeDeleteManyArgs>(
    args: Subset<T, ContributorAttributeDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more ContributorAttributes.
   * @param {ContributorAttributeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ContributorAttributes
   * const contributorAttribute = await prisma.contributorAttribute.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ContributorAttributeUpdateManyArgs>(
    args: Subset<T, ContributorAttributeUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one ContributorAttribute.
   * @param {ContributorAttributeUpsertArgs} args - Arguments to update or create a ContributorAttribute.
   * @example
   * // Update or create a ContributorAttribute
   * const contributorAttribute = await prisma.contributorAttribute.upsert({
   *   create: {
   *     // ... data to create a ContributorAttribute
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ContributorAttribute we want to update
   *   }
   * })
  **/
  upsert<T extends ContributorAttributeUpsertArgs>(
    args: Subset<T, ContributorAttributeUpsertArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeClient<ContributorAttribute>, Prisma__ContributorAttributeClient<ContributorAttributeGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyContributorAttributeArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateContributorAttributeArgs>(args: Subset<T, AggregateContributorAttributeArgs>): Promise<GetContributorAttributeAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for ContributorAttribute.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ContributorAttributeClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>;

  contributorAttributeValues<T extends FindManyContributorAttributeValueArgs = {}>(args?: Subset<T, FindManyContributorAttributeValueArgs>): CheckSelect<T, Promise<Array<ContributorAttributeValue>>, Promise<Array<ContributorAttributeValueGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * ContributorAttribute findOne
 */
export type FindOneContributorAttributeArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
  /**
   * Filter, which ContributorAttribute to fetch.
  **/
  where: ContributorAttributeWhereUniqueInput
}


/**
 * ContributorAttribute findFirst
 */
export type FindFirstContributorAttributeArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
  /**
   * Filter, which ContributorAttribute to fetch.
  **/
  where?: ContributorAttributeWhereInput
  orderBy?: Enumerable<ContributorAttributeOrderByInput> | ContributorAttributeOrderByInput
  cursor?: ContributorAttributeWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ContributorAttributeDistinctFieldEnum>
}


/**
 * ContributorAttribute findMany
 */
export type FindManyContributorAttributeArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
  /**
   * Filter, which ContributorAttributes to fetch.
  **/
  where?: ContributorAttributeWhereInput
  /**
   * Determine the order of the ContributorAttributes to fetch.
  **/
  orderBy?: Enumerable<ContributorAttributeOrderByInput> | ContributorAttributeOrderByInput
  /**
   * Sets the position for listing ContributorAttributes.
  **/
  cursor?: ContributorAttributeWhereUniqueInput
  /**
   * The number of ContributorAttributes to fetch. If negative number, it will take ContributorAttributes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` ContributorAttributes.
  **/
  skip?: number
  distinct?: Enumerable<ContributorAttributeDistinctFieldEnum>
}


/**
 * ContributorAttribute create
 */
export type ContributorAttributeCreateArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
  /**
   * The data needed to create a ContributorAttribute.
  **/
  data: ContributorAttributeCreateInput
}


/**
 * ContributorAttribute update
 */
export type ContributorAttributeUpdateArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
  /**
   * The data needed to update a ContributorAttribute.
  **/
  data: ContributorAttributeUpdateInput
  /**
   * Choose, which ContributorAttribute to update.
  **/
  where: ContributorAttributeWhereUniqueInput
}


/**
 * ContributorAttribute updateMany
 */
export type ContributorAttributeUpdateManyArgs = {
  data: ContributorAttributeUpdateManyMutationInput
  where?: ContributorAttributeWhereInput
}


/**
 * ContributorAttribute upsert
 */
export type ContributorAttributeUpsertArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
  /**
   * The filter to search for the ContributorAttribute to update in case it exists.
  **/
  where: ContributorAttributeWhereUniqueInput
  /**
   * In case the ContributorAttribute found by the `where` argument doesn't exist, create a new ContributorAttribute with this data.
  **/
  create: ContributorAttributeCreateInput
  /**
   * In case the ContributorAttribute was found with the provided `where` argument, update it with this data.
  **/
  update: ContributorAttributeUpdateInput
}


/**
 * ContributorAttribute delete
 */
export type ContributorAttributeDeleteArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
  /**
   * Filter which ContributorAttribute to delete.
  **/
  where: ContributorAttributeWhereUniqueInput
}


/**
 * ContributorAttribute deleteMany
 */
export type ContributorAttributeDeleteManyArgs = {
  where?: ContributorAttributeWhereInput
}


/**
 * ContributorAttribute without action
 */
export type ContributorAttributeArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttribute
  **/
  select?: ContributorAttributeSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeInclude | null
}



/**
 * Model ContributorAttributeValue
 */

export type ContributorAttributeValue = {
  id: number
  contributorAttributeId: number
  contributorAttributeType: CONTRIBUTOR_ATTRIBUTE_TYPE
  personId: number
  organizationId: number
  valuetext: string | null
}


export type AggregateContributorAttributeValue = {
  count: number
  avg: ContributorAttributeValueAvgAggregateOutputType | null
  sum: ContributorAttributeValueSumAggregateOutputType | null
  min: ContributorAttributeValueMinAggregateOutputType | null
  max: ContributorAttributeValueMaxAggregateOutputType | null
}

export type ContributorAttributeValueAvgAggregateOutputType = {
  id: number
  contributorAttributeId: number
  personId: number
  organizationId: number
}

export type ContributorAttributeValueSumAggregateOutputType = {
  id: number
  contributorAttributeId: number
  personId: number
  organizationId: number
}

export type ContributorAttributeValueMinAggregateOutputType = {
  id: number
  contributorAttributeId: number
  personId: number
  organizationId: number
}

export type ContributorAttributeValueMaxAggregateOutputType = {
  id: number
  contributorAttributeId: number
  personId: number
  organizationId: number
}


export type ContributorAttributeValueAvgAggregateInputType = {
  id?: true
  contributorAttributeId?: true
  personId?: true
  organizationId?: true
}

export type ContributorAttributeValueSumAggregateInputType = {
  id?: true
  contributorAttributeId?: true
  personId?: true
  organizationId?: true
}

export type ContributorAttributeValueMinAggregateInputType = {
  id?: true
  contributorAttributeId?: true
  personId?: true
  organizationId?: true
}

export type ContributorAttributeValueMaxAggregateInputType = {
  id?: true
  contributorAttributeId?: true
  personId?: true
  organizationId?: true
}

export type AggregateContributorAttributeValueArgs = {
  where?: ContributorAttributeValueWhereInput
  orderBy?: Enumerable<ContributorAttributeValueOrderByInput> | ContributorAttributeValueOrderByInput
  cursor?: ContributorAttributeValueWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ContributorAttributeValueDistinctFieldEnum>
  count?: true
  avg?: ContributorAttributeValueAvgAggregateInputType
  sum?: ContributorAttributeValueSumAggregateInputType
  min?: ContributorAttributeValueMinAggregateInputType
  max?: ContributorAttributeValueMaxAggregateInputType
}

export type GetContributorAttributeValueAggregateType<T extends AggregateContributorAttributeValueArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetContributorAttributeValueAggregateScalarType<T[P]>
}

export type GetContributorAttributeValueAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ContributorAttributeValueAvgAggregateOutputType ? ContributorAttributeValueAvgAggregateOutputType[P] : never
}
    
    

export type ContributorAttributeValueSelect = {
  id?: boolean
  contributorAttributeId?: boolean
  contributorAttributeType?: boolean
  personId?: boolean
  organizationId?: boolean
  valuetext?: boolean
  contributorAttribute?: boolean | ContributorAttributeArgs
  organization?: boolean | OrganizationArgs
  person?: boolean | PersonArgs
}

export type ContributorAttributeValueInclude = {
  contributorAttribute?: boolean | ContributorAttributeArgs
  organization?: boolean | OrganizationArgs
  person?: boolean | PersonArgs
}

export type ContributorAttributeValueGetPayload<
  S extends boolean | null | undefined | ContributorAttributeValueArgs,
  U = keyof S
> = S extends true
  ? ContributorAttributeValue
  : S extends undefined
  ? never
  : S extends ContributorAttributeValueArgs | FindManyContributorAttributeValueArgs
  ? 'include' extends U
    ? ContributorAttributeValue  & {
      [P in TrueKeys<S['include']>]:
      P extends 'contributorAttribute'
      ? ContributorAttributeGetPayload<S['include'][P]> :
      P extends 'organization'
      ? OrganizationGetPayload<S['include'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof ContributorAttributeValue ? ContributorAttributeValue[P]
: 
      P extends 'contributorAttribute'
      ? ContributorAttributeGetPayload<S['select'][P]> :
      P extends 'organization'
      ? OrganizationGetPayload<S['select'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['select'][P]> : never
    }
  : ContributorAttributeValue
: ContributorAttributeValue


export interface ContributorAttributeValueDelegate {
  /**
   * Find zero or one ContributorAttributeValue that matches the filter.
   * @param {FindOneContributorAttributeValueArgs} args - Arguments to find a ContributorAttributeValue
   * @example
   * // Get one ContributorAttributeValue
   * const contributorAttributeValue = await prisma.contributorAttributeValue.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneContributorAttributeValueArgs>(
    args: Subset<T, FindOneContributorAttributeValueArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeValueClient<ContributorAttributeValue | null>, Prisma__ContributorAttributeValueClient<ContributorAttributeValueGetPayload<T> | null>>
  /**
   * Find the first ContributorAttributeValue that matches the filter.
   * @param {FindFirstContributorAttributeValueArgs} args - Arguments to find a ContributorAttributeValue
   * @example
   * // Get one ContributorAttributeValue
   * const contributorAttributeValue = await prisma.contributorAttributeValue.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstContributorAttributeValueArgs>(
    args?: Subset<T, FindFirstContributorAttributeValueArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeValueClient<ContributorAttributeValue | null>, Prisma__ContributorAttributeValueClient<ContributorAttributeValueGetPayload<T> | null>>
  /**
   * Find zero or more ContributorAttributeValues that matches the filter.
   * @param {FindManyContributorAttributeValueArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ContributorAttributeValues
   * const contributorAttributeValues = await prisma.contributorAttributeValue.findMany()
   * 
   * // Get first 10 ContributorAttributeValues
   * const contributorAttributeValues = await prisma.contributorAttributeValue.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const contributorAttributeValueWithIdOnly = await prisma.contributorAttributeValue.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyContributorAttributeValueArgs>(
    args?: Subset<T, FindManyContributorAttributeValueArgs>
  ): CheckSelect<T, Promise<Array<ContributorAttributeValue>>, Promise<Array<ContributorAttributeValueGetPayload<T>>>>
  /**
   * Create a ContributorAttributeValue.
   * @param {ContributorAttributeValueCreateArgs} args - Arguments to create a ContributorAttributeValue.
   * @example
   * // Create one ContributorAttributeValue
   * const ContributorAttributeValue = await prisma.contributorAttributeValue.create({
   *   data: {
   *     // ... data to create a ContributorAttributeValue
   *   }
   * })
   * 
  **/
  create<T extends ContributorAttributeValueCreateArgs>(
    args: Subset<T, ContributorAttributeValueCreateArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeValueClient<ContributorAttributeValue>, Prisma__ContributorAttributeValueClient<ContributorAttributeValueGetPayload<T>>>
  /**
   * Delete a ContributorAttributeValue.
   * @param {ContributorAttributeValueDeleteArgs} args - Arguments to delete one ContributorAttributeValue.
   * @example
   * // Delete one ContributorAttributeValue
   * const ContributorAttributeValue = await prisma.contributorAttributeValue.delete({
   *   where: {
   *     // ... filter to delete one ContributorAttributeValue
   *   }
   * })
   * 
  **/
  delete<T extends ContributorAttributeValueDeleteArgs>(
    args: Subset<T, ContributorAttributeValueDeleteArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeValueClient<ContributorAttributeValue>, Prisma__ContributorAttributeValueClient<ContributorAttributeValueGetPayload<T>>>
  /**
   * Update one ContributorAttributeValue.
   * @param {ContributorAttributeValueUpdateArgs} args - Arguments to update one ContributorAttributeValue.
   * @example
   * // Update one ContributorAttributeValue
   * const contributorAttributeValue = await prisma.contributorAttributeValue.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ContributorAttributeValueUpdateArgs>(
    args: Subset<T, ContributorAttributeValueUpdateArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeValueClient<ContributorAttributeValue>, Prisma__ContributorAttributeValueClient<ContributorAttributeValueGetPayload<T>>>
  /**
   * Delete zero or more ContributorAttributeValues.
   * @param {ContributorAttributeValueDeleteManyArgs} args - Arguments to filter ContributorAttributeValues to delete.
   * @example
   * // Delete a few ContributorAttributeValues
   * const { count } = await prisma.contributorAttributeValue.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ContributorAttributeValueDeleteManyArgs>(
    args: Subset<T, ContributorAttributeValueDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more ContributorAttributeValues.
   * @param {ContributorAttributeValueUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ContributorAttributeValues
   * const contributorAttributeValue = await prisma.contributorAttributeValue.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ContributorAttributeValueUpdateManyArgs>(
    args: Subset<T, ContributorAttributeValueUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one ContributorAttributeValue.
   * @param {ContributorAttributeValueUpsertArgs} args - Arguments to update or create a ContributorAttributeValue.
   * @example
   * // Update or create a ContributorAttributeValue
   * const contributorAttributeValue = await prisma.contributorAttributeValue.upsert({
   *   create: {
   *     // ... data to create a ContributorAttributeValue
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ContributorAttributeValue we want to update
   *   }
   * })
  **/
  upsert<T extends ContributorAttributeValueUpsertArgs>(
    args: Subset<T, ContributorAttributeValueUpsertArgs>
  ): CheckSelect<T, Prisma__ContributorAttributeValueClient<ContributorAttributeValue>, Prisma__ContributorAttributeValueClient<ContributorAttributeValueGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyContributorAttributeValueArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateContributorAttributeValueArgs>(args: Subset<T, AggregateContributorAttributeValueArgs>): Promise<GetContributorAttributeValueAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for ContributorAttributeValue.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ContributorAttributeValueClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  contributorAttribute<T extends ContributorAttributeArgs = {}>(args?: Subset<T, ContributorAttributeArgs>): CheckSelect<T, Prisma__ContributorAttributeClient<ContributorAttribute | null>, Prisma__ContributorAttributeClient<ContributorAttributeGetPayload<T> | null>>;

  organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | null>>;

  person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * ContributorAttributeValue findOne
 */
export type FindOneContributorAttributeValueArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
  /**
   * Filter, which ContributorAttributeValue to fetch.
  **/
  where: ContributorAttributeValueWhereUniqueInput
}


/**
 * ContributorAttributeValue findFirst
 */
export type FindFirstContributorAttributeValueArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
  /**
   * Filter, which ContributorAttributeValue to fetch.
  **/
  where?: ContributorAttributeValueWhereInput
  orderBy?: Enumerable<ContributorAttributeValueOrderByInput> | ContributorAttributeValueOrderByInput
  cursor?: ContributorAttributeValueWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ContributorAttributeValueDistinctFieldEnum>
}


/**
 * ContributorAttributeValue findMany
 */
export type FindManyContributorAttributeValueArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
  /**
   * Filter, which ContributorAttributeValues to fetch.
  **/
  where?: ContributorAttributeValueWhereInput
  /**
   * Determine the order of the ContributorAttributeValues to fetch.
  **/
  orderBy?: Enumerable<ContributorAttributeValueOrderByInput> | ContributorAttributeValueOrderByInput
  /**
   * Sets the position for listing ContributorAttributeValues.
  **/
  cursor?: ContributorAttributeValueWhereUniqueInput
  /**
   * The number of ContributorAttributeValues to fetch. If negative number, it will take ContributorAttributeValues before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` ContributorAttributeValues.
  **/
  skip?: number
  distinct?: Enumerable<ContributorAttributeValueDistinctFieldEnum>
}


/**
 * ContributorAttributeValue create
 */
export type ContributorAttributeValueCreateArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
  /**
   * The data needed to create a ContributorAttributeValue.
  **/
  data: ContributorAttributeValueCreateInput
}


/**
 * ContributorAttributeValue update
 */
export type ContributorAttributeValueUpdateArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
  /**
   * The data needed to update a ContributorAttributeValue.
  **/
  data: ContributorAttributeValueUpdateInput
  /**
   * Choose, which ContributorAttributeValue to update.
  **/
  where: ContributorAttributeValueWhereUniqueInput
}


/**
 * ContributorAttributeValue updateMany
 */
export type ContributorAttributeValueUpdateManyArgs = {
  data: ContributorAttributeValueUpdateManyMutationInput
  where?: ContributorAttributeValueWhereInput
}


/**
 * ContributorAttributeValue upsert
 */
export type ContributorAttributeValueUpsertArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
  /**
   * The filter to search for the ContributorAttributeValue to update in case it exists.
  **/
  where: ContributorAttributeValueWhereUniqueInput
  /**
   * In case the ContributorAttributeValue found by the `where` argument doesn't exist, create a new ContributorAttributeValue with this data.
  **/
  create: ContributorAttributeValueCreateInput
  /**
   * In case the ContributorAttributeValue was found with the provided `where` argument, update it with this data.
  **/
  update: ContributorAttributeValueUpdateInput
}


/**
 * ContributorAttributeValue delete
 */
export type ContributorAttributeValueDeleteArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
  /**
   * Filter which ContributorAttributeValue to delete.
  **/
  where: ContributorAttributeValueWhereUniqueInput
}


/**
 * ContributorAttributeValue deleteMany
 */
export type ContributorAttributeValueDeleteManyArgs = {
  where?: ContributorAttributeValueWhereInput
}


/**
 * ContributorAttributeValue without action
 */
export type ContributorAttributeValueArgs = {
  /**
   * Select specific fields to fetch from the ContributorAttributeValue
  **/
  select?: ContributorAttributeValueSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContributorAttributeValueInclude | null
}



/**
 * Model Discovery
 */

export type Discovery = {
  projectId: number
  id: number
  title: string
  description: string | null
}


export type AggregateDiscovery = {
  count: number
  avg: DiscoveryAvgAggregateOutputType | null
  sum: DiscoverySumAggregateOutputType | null
  min: DiscoveryMinAggregateOutputType | null
  max: DiscoveryMaxAggregateOutputType | null
}

export type DiscoveryAvgAggregateOutputType = {
  projectId: number
  id: number
}

export type DiscoverySumAggregateOutputType = {
  projectId: number
  id: number
}

export type DiscoveryMinAggregateOutputType = {
  projectId: number
  id: number
}

export type DiscoveryMaxAggregateOutputType = {
  projectId: number
  id: number
}


export type DiscoveryAvgAggregateInputType = {
  projectId?: true
  id?: true
}

export type DiscoverySumAggregateInputType = {
  projectId?: true
  id?: true
}

export type DiscoveryMinAggregateInputType = {
  projectId?: true
  id?: true
}

export type DiscoveryMaxAggregateInputType = {
  projectId?: true
  id?: true
}

export type AggregateDiscoveryArgs = {
  where?: DiscoveryWhereInput
  orderBy?: Enumerable<DiscoveryOrderByInput> | DiscoveryOrderByInput
  cursor?: DiscoveryWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DiscoveryDistinctFieldEnum>
  count?: true
  avg?: DiscoveryAvgAggregateInputType
  sum?: DiscoverySumAggregateInputType
  min?: DiscoveryMinAggregateInputType
  max?: DiscoveryMaxAggregateInputType
}

export type GetDiscoveryAggregateType<T extends AggregateDiscoveryArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetDiscoveryAggregateScalarType<T[P]>
}

export type GetDiscoveryAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof DiscoveryAvgAggregateOutputType ? DiscoveryAvgAggregateOutputType[P] : never
}
    
    

export type DiscoverySelect = {
  projectId?: boolean
  id?: boolean
  title?: boolean
  description?: boolean
  project?: boolean | ProjectArgs
  chunks?: boolean | FindManyChunkArgs
}

export type DiscoveryInclude = {
  project?: boolean | ProjectArgs
  chunks?: boolean | FindManyChunkArgs
}

export type DiscoveryGetPayload<
  S extends boolean | null | undefined | DiscoveryArgs,
  U = keyof S
> = S extends true
  ? Discovery
  : S extends undefined
  ? never
  : S extends DiscoveryArgs | FindManyDiscoveryArgs
  ? 'include' extends U
    ? Discovery  & {
      [P in TrueKeys<S['include']>]:
      P extends 'project'
      ? ProjectGetPayload<S['include'][P]> :
      P extends 'chunks'
      ? Array<ChunkGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Discovery ? Discovery[P]
: 
      P extends 'project'
      ? ProjectGetPayload<S['select'][P]> :
      P extends 'chunks'
      ? Array<ChunkGetPayload<S['select'][P]>> : never
    }
  : Discovery
: Discovery


export interface DiscoveryDelegate {
  /**
   * Find zero or one Discovery that matches the filter.
   * @param {FindOneDiscoveryArgs} args - Arguments to find a Discovery
   * @example
   * // Get one Discovery
   * const discovery = await prisma.discovery.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneDiscoveryArgs>(
    args: Subset<T, FindOneDiscoveryArgs>
  ): CheckSelect<T, Prisma__DiscoveryClient<Discovery | null>, Prisma__DiscoveryClient<DiscoveryGetPayload<T> | null>>
  /**
   * Find the first Discovery that matches the filter.
   * @param {FindFirstDiscoveryArgs} args - Arguments to find a Discovery
   * @example
   * // Get one Discovery
   * const discovery = await prisma.discovery.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstDiscoveryArgs>(
    args?: Subset<T, FindFirstDiscoveryArgs>
  ): CheckSelect<T, Prisma__DiscoveryClient<Discovery | null>, Prisma__DiscoveryClient<DiscoveryGetPayload<T> | null>>
  /**
   * Find zero or more Discoveries that matches the filter.
   * @param {FindManyDiscoveryArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Discoveries
   * const discoveries = await prisma.discovery.findMany()
   * 
   * // Get first 10 Discoveries
   * const discoveries = await prisma.discovery.findMany({ take: 10 })
   * 
   * // Only select the `projectId`
   * const discoveryWithProjectIdOnly = await prisma.discovery.findMany({ select: { projectId: true } })
   * 
  **/
  findMany<T extends FindManyDiscoveryArgs>(
    args?: Subset<T, FindManyDiscoveryArgs>
  ): CheckSelect<T, Promise<Array<Discovery>>, Promise<Array<DiscoveryGetPayload<T>>>>
  /**
   * Create a Discovery.
   * @param {DiscoveryCreateArgs} args - Arguments to create a Discovery.
   * @example
   * // Create one Discovery
   * const Discovery = await prisma.discovery.create({
   *   data: {
   *     // ... data to create a Discovery
   *   }
   * })
   * 
  **/
  create<T extends DiscoveryCreateArgs>(
    args: Subset<T, DiscoveryCreateArgs>
  ): CheckSelect<T, Prisma__DiscoveryClient<Discovery>, Prisma__DiscoveryClient<DiscoveryGetPayload<T>>>
  /**
   * Delete a Discovery.
   * @param {DiscoveryDeleteArgs} args - Arguments to delete one Discovery.
   * @example
   * // Delete one Discovery
   * const Discovery = await prisma.discovery.delete({
   *   where: {
   *     // ... filter to delete one Discovery
   *   }
   * })
   * 
  **/
  delete<T extends DiscoveryDeleteArgs>(
    args: Subset<T, DiscoveryDeleteArgs>
  ): CheckSelect<T, Prisma__DiscoveryClient<Discovery>, Prisma__DiscoveryClient<DiscoveryGetPayload<T>>>
  /**
   * Update one Discovery.
   * @param {DiscoveryUpdateArgs} args - Arguments to update one Discovery.
   * @example
   * // Update one Discovery
   * const discovery = await prisma.discovery.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends DiscoveryUpdateArgs>(
    args: Subset<T, DiscoveryUpdateArgs>
  ): CheckSelect<T, Prisma__DiscoveryClient<Discovery>, Prisma__DiscoveryClient<DiscoveryGetPayload<T>>>
  /**
   * Delete zero or more Discoveries.
   * @param {DiscoveryDeleteManyArgs} args - Arguments to filter Discoveries to delete.
   * @example
   * // Delete a few Discoveries
   * const { count } = await prisma.discovery.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends DiscoveryDeleteManyArgs>(
    args: Subset<T, DiscoveryDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Discoveries.
   * @param {DiscoveryUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Discoveries
   * const discovery = await prisma.discovery.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends DiscoveryUpdateManyArgs>(
    args: Subset<T, DiscoveryUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Discovery.
   * @param {DiscoveryUpsertArgs} args - Arguments to update or create a Discovery.
   * @example
   * // Update or create a Discovery
   * const discovery = await prisma.discovery.upsert({
   *   create: {
   *     // ... data to create a Discovery
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Discovery we want to update
   *   }
   * })
  **/
  upsert<T extends DiscoveryUpsertArgs>(
    args: Subset<T, DiscoveryUpsertArgs>
  ): CheckSelect<T, Prisma__DiscoveryClient<Discovery>, Prisma__DiscoveryClient<DiscoveryGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyDiscoveryArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDiscoveryArgs>(args: Subset<T, AggregateDiscoveryArgs>): Promise<GetDiscoveryAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Discovery.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__DiscoveryClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>;

  chunks<T extends FindManyChunkArgs = {}>(args?: Subset<T, FindManyChunkArgs>): CheckSelect<T, Promise<Array<Chunk>>, Promise<Array<ChunkGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Discovery findOne
 */
export type FindOneDiscoveryArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
  /**
   * Filter, which Discovery to fetch.
  **/
  where: DiscoveryWhereUniqueInput
}


/**
 * Discovery findFirst
 */
export type FindFirstDiscoveryArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
  /**
   * Filter, which Discovery to fetch.
  **/
  where?: DiscoveryWhereInput
  orderBy?: Enumerable<DiscoveryOrderByInput> | DiscoveryOrderByInput
  cursor?: DiscoveryWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DiscoveryDistinctFieldEnum>
}


/**
 * Discovery findMany
 */
export type FindManyDiscoveryArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
  /**
   * Filter, which Discoveries to fetch.
  **/
  where?: DiscoveryWhereInput
  /**
   * Determine the order of the Discoveries to fetch.
  **/
  orderBy?: Enumerable<DiscoveryOrderByInput> | DiscoveryOrderByInput
  /**
   * Sets the position for listing Discoveries.
  **/
  cursor?: DiscoveryWhereUniqueInput
  /**
   * The number of Discoveries to fetch. If negative number, it will take Discoveries before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Discoveries.
  **/
  skip?: number
  distinct?: Enumerable<DiscoveryDistinctFieldEnum>
}


/**
 * Discovery create
 */
export type DiscoveryCreateArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
  /**
   * The data needed to create a Discovery.
  **/
  data: DiscoveryCreateInput
}


/**
 * Discovery update
 */
export type DiscoveryUpdateArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
  /**
   * The data needed to update a Discovery.
  **/
  data: DiscoveryUpdateInput
  /**
   * Choose, which Discovery to update.
  **/
  where: DiscoveryWhereUniqueInput
}


/**
 * Discovery updateMany
 */
export type DiscoveryUpdateManyArgs = {
  data: DiscoveryUpdateManyMutationInput
  where?: DiscoveryWhereInput
}


/**
 * Discovery upsert
 */
export type DiscoveryUpsertArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
  /**
   * The filter to search for the Discovery to update in case it exists.
  **/
  where: DiscoveryWhereUniqueInput
  /**
   * In case the Discovery found by the `where` argument doesn't exist, create a new Discovery with this data.
  **/
  create: DiscoveryCreateInput
  /**
   * In case the Discovery was found with the provided `where` argument, update it with this data.
  **/
  update: DiscoveryUpdateInput
}


/**
 * Discovery delete
 */
export type DiscoveryDeleteArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
  /**
   * Filter which Discovery to delete.
  **/
  where: DiscoveryWhereUniqueInput
}


/**
 * Discovery deleteMany
 */
export type DiscoveryDeleteManyArgs = {
  where?: DiscoveryWhereInput
}


/**
 * Discovery without action
 */
export type DiscoveryArgs = {
  /**
   * Select specific fields to fetch from the Discovery
  **/
  select?: DiscoverySelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: DiscoveryInclude | null
}



/**
 * Model Message
 */

export type Message = {
  projectId: number
  id: number
  requesterId: number
  submitterId: number
  clientId: string | null
  title: string | null
  content: string | null
}


export type AggregateMessage = {
  count: number
  avg: MessageAvgAggregateOutputType | null
  sum: MessageSumAggregateOutputType | null
  min: MessageMinAggregateOutputType | null
  max: MessageMaxAggregateOutputType | null
}

export type MessageAvgAggregateOutputType = {
  projectId: number
  id: number
  requesterId: number
  submitterId: number
}

export type MessageSumAggregateOutputType = {
  projectId: number
  id: number
  requesterId: number
  submitterId: number
}

export type MessageMinAggregateOutputType = {
  projectId: number
  id: number
  requesterId: number
  submitterId: number
}

export type MessageMaxAggregateOutputType = {
  projectId: number
  id: number
  requesterId: number
  submitterId: number
}


export type MessageAvgAggregateInputType = {
  projectId?: true
  id?: true
  requesterId?: true
  submitterId?: true
}

export type MessageSumAggregateInputType = {
  projectId?: true
  id?: true
  requesterId?: true
  submitterId?: true
}

export type MessageMinAggregateInputType = {
  projectId?: true
  id?: true
  requesterId?: true
  submitterId?: true
}

export type MessageMaxAggregateInputType = {
  projectId?: true
  id?: true
  requesterId?: true
  submitterId?: true
}

export type AggregateMessageArgs = {
  where?: MessageWhereInput
  orderBy?: Enumerable<MessageOrderByInput> | MessageOrderByInput
  cursor?: MessageWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MessageDistinctFieldEnum>
  count?: true
  avg?: MessageAvgAggregateInputType
  sum?: MessageSumAggregateInputType
  min?: MessageMinAggregateInputType
  max?: MessageMaxAggregateInputType
}

export type GetMessageAggregateType<T extends AggregateMessageArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetMessageAggregateScalarType<T[P]>
}

export type GetMessageAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof MessageAvgAggregateOutputType ? MessageAvgAggregateOutputType[P] : never
}
    
    

export type MessageSelect = {
  projectId?: boolean
  id?: boolean
  requesterId?: boolean
  submitterId?: boolean
  clientId?: boolean
  title?: boolean
  content?: boolean
  project?: boolean | ProjectArgs
  person_Message_requesterIdToPerson?: boolean | PersonArgs
  person_Message_submitterIdToPerson?: boolean | PersonArgs
  chunks?: boolean | FindManyChunkArgs
  subMessages?: boolean | FindManySubMessageArgs
}

export type MessageInclude = {
  project?: boolean | ProjectArgs
  person_Message_requesterIdToPerson?: boolean | PersonArgs
  person_Message_submitterIdToPerson?: boolean | PersonArgs
  chunks?: boolean | FindManyChunkArgs
  subMessages?: boolean | FindManySubMessageArgs
}

export type MessageGetPayload<
  S extends boolean | null | undefined | MessageArgs,
  U = keyof S
> = S extends true
  ? Message
  : S extends undefined
  ? never
  : S extends MessageArgs | FindManyMessageArgs
  ? 'include' extends U
    ? Message  & {
      [P in TrueKeys<S['include']>]:
      P extends 'project'
      ? ProjectGetPayload<S['include'][P]> :
      P extends 'person_Message_requesterIdToPerson'
      ? PersonGetPayload<S['include'][P]> :
      P extends 'person_Message_submitterIdToPerson'
      ? PersonGetPayload<S['include'][P]> :
      P extends 'chunks'
      ? Array<ChunkGetPayload<S['include'][P]>> :
      P extends 'subMessages'
      ? Array<SubMessageGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Message ? Message[P]
: 
      P extends 'project'
      ? ProjectGetPayload<S['select'][P]> :
      P extends 'person_Message_requesterIdToPerson'
      ? PersonGetPayload<S['select'][P]> :
      P extends 'person_Message_submitterIdToPerson'
      ? PersonGetPayload<S['select'][P]> :
      P extends 'chunks'
      ? Array<ChunkGetPayload<S['select'][P]>> :
      P extends 'subMessages'
      ? Array<SubMessageGetPayload<S['select'][P]>> : never
    }
  : Message
: Message


export interface MessageDelegate {
  /**
   * Find zero or one Message that matches the filter.
   * @param {FindOneMessageArgs} args - Arguments to find a Message
   * @example
   * // Get one Message
   * const message = await prisma.message.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneMessageArgs>(
    args: Subset<T, FindOneMessageArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message | null>, Prisma__MessageClient<MessageGetPayload<T> | null>>
  /**
   * Find the first Message that matches the filter.
   * @param {FindFirstMessageArgs} args - Arguments to find a Message
   * @example
   * // Get one Message
   * const message = await prisma.message.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstMessageArgs>(
    args?: Subset<T, FindFirstMessageArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message | null>, Prisma__MessageClient<MessageGetPayload<T> | null>>
  /**
   * Find zero or more Messages that matches the filter.
   * @param {FindManyMessageArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Messages
   * const messages = await prisma.message.findMany()
   * 
   * // Get first 10 Messages
   * const messages = await prisma.message.findMany({ take: 10 })
   * 
   * // Only select the `projectId`
   * const messageWithProjectIdOnly = await prisma.message.findMany({ select: { projectId: true } })
   * 
  **/
  findMany<T extends FindManyMessageArgs>(
    args?: Subset<T, FindManyMessageArgs>
  ): CheckSelect<T, Promise<Array<Message>>, Promise<Array<MessageGetPayload<T>>>>
  /**
   * Create a Message.
   * @param {MessageCreateArgs} args - Arguments to create a Message.
   * @example
   * // Create one Message
   * const Message = await prisma.message.create({
   *   data: {
   *     // ... data to create a Message
   *   }
   * })
   * 
  **/
  create<T extends MessageCreateArgs>(
    args: Subset<T, MessageCreateArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Delete a Message.
   * @param {MessageDeleteArgs} args - Arguments to delete one Message.
   * @example
   * // Delete one Message
   * const Message = await prisma.message.delete({
   *   where: {
   *     // ... filter to delete one Message
   *   }
   * })
   * 
  **/
  delete<T extends MessageDeleteArgs>(
    args: Subset<T, MessageDeleteArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Update one Message.
   * @param {MessageUpdateArgs} args - Arguments to update one Message.
   * @example
   * // Update one Message
   * const message = await prisma.message.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends MessageUpdateArgs>(
    args: Subset<T, MessageUpdateArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Delete zero or more Messages.
   * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
   * @example
   * // Delete a few Messages
   * const { count } = await prisma.message.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends MessageDeleteManyArgs>(
    args: Subset<T, MessageDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Messages.
   * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Messages
   * const message = await prisma.message.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends MessageUpdateManyArgs>(
    args: Subset<T, MessageUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Message.
   * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
   * @example
   * // Update or create a Message
   * const message = await prisma.message.upsert({
   *   create: {
   *     // ... data to create a Message
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Message we want to update
   *   }
   * })
  **/
  upsert<T extends MessageUpsertArgs>(
    args: Subset<T, MessageUpsertArgs>
  ): CheckSelect<T, Prisma__MessageClient<Message>, Prisma__MessageClient<MessageGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyMessageArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateMessageArgs>(args: Subset<T, AggregateMessageArgs>): Promise<GetMessageAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Message.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__MessageClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>;

  person_Message_requesterIdToPerson<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>;

  person_Message_submitterIdToPerson<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>;

  chunks<T extends FindManyChunkArgs = {}>(args?: Subset<T, FindManyChunkArgs>): CheckSelect<T, Promise<Array<Chunk>>, Promise<Array<ChunkGetPayload<T>>>>;

  subMessages<T extends FindManySubMessageArgs = {}>(args?: Subset<T, FindManySubMessageArgs>): CheckSelect<T, Promise<Array<SubMessage>>, Promise<Array<SubMessageGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Message findOne
 */
export type FindOneMessageArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * Filter, which Message to fetch.
  **/
  where: MessageWhereUniqueInput
}


/**
 * Message findFirst
 */
export type FindFirstMessageArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * Filter, which Message to fetch.
  **/
  where?: MessageWhereInput
  orderBy?: Enumerable<MessageOrderByInput> | MessageOrderByInput
  cursor?: MessageWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MessageDistinctFieldEnum>
}


/**
 * Message findMany
 */
export type FindManyMessageArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * Filter, which Messages to fetch.
  **/
  where?: MessageWhereInput
  /**
   * Determine the order of the Messages to fetch.
  **/
  orderBy?: Enumerable<MessageOrderByInput> | MessageOrderByInput
  /**
   * Sets the position for listing Messages.
  **/
  cursor?: MessageWhereUniqueInput
  /**
   * The number of Messages to fetch. If negative number, it will take Messages before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Messages.
  **/
  skip?: number
  distinct?: Enumerable<MessageDistinctFieldEnum>
}


/**
 * Message create
 */
export type MessageCreateArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * The data needed to create a Message.
  **/
  data: MessageCreateInput
}


/**
 * Message update
 */
export type MessageUpdateArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * The data needed to update a Message.
  **/
  data: MessageUpdateInput
  /**
   * Choose, which Message to update.
  **/
  where: MessageWhereUniqueInput
}


/**
 * Message updateMany
 */
export type MessageUpdateManyArgs = {
  data: MessageUpdateManyMutationInput
  where?: MessageWhereInput
}


/**
 * Message upsert
 */
export type MessageUpsertArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * The filter to search for the Message to update in case it exists.
  **/
  where: MessageWhereUniqueInput
  /**
   * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
  **/
  create: MessageCreateInput
  /**
   * In case the Message was found with the provided `where` argument, update it with this data.
  **/
  update: MessageUpdateInput
}


/**
 * Message delete
 */
export type MessageDeleteArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
  /**
   * Filter which Message to delete.
  **/
  where: MessageWhereUniqueInput
}


/**
 * Message deleteMany
 */
export type MessageDeleteManyArgs = {
  where?: MessageWhereInput
}


/**
 * Message without action
 */
export type MessageArgs = {
  /**
   * Select specific fields to fetch from the Message
  **/
  select?: MessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MessageInclude | null
}



/**
 * Model Organization
 */

export type Organization = {
  projectId: number
  id: number
  name: string
}


export type AggregateOrganization = {
  count: number
  avg: OrganizationAvgAggregateOutputType | null
  sum: OrganizationSumAggregateOutputType | null
  min: OrganizationMinAggregateOutputType | null
  max: OrganizationMaxAggregateOutputType | null
}

export type OrganizationAvgAggregateOutputType = {
  projectId: number
  id: number
}

export type OrganizationSumAggregateOutputType = {
  projectId: number
  id: number
}

export type OrganizationMinAggregateOutputType = {
  projectId: number
  id: number
}

export type OrganizationMaxAggregateOutputType = {
  projectId: number
  id: number
}


export type OrganizationAvgAggregateInputType = {
  projectId?: true
  id?: true
}

export type OrganizationSumAggregateInputType = {
  projectId?: true
  id?: true
}

export type OrganizationMinAggregateInputType = {
  projectId?: true
  id?: true
}

export type OrganizationMaxAggregateInputType = {
  projectId?: true
  id?: true
}

export type AggregateOrganizationArgs = {
  where?: OrganizationWhereInput
  orderBy?: Enumerable<OrganizationOrderByInput> | OrganizationOrderByInput
  cursor?: OrganizationWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OrganizationDistinctFieldEnum>
  count?: true
  avg?: OrganizationAvgAggregateInputType
  sum?: OrganizationSumAggregateInputType
  min?: OrganizationMinAggregateInputType
  max?: OrganizationMaxAggregateInputType
}

export type GetOrganizationAggregateType<T extends AggregateOrganizationArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOrganizationAggregateScalarType<T[P]>
}

export type GetOrganizationAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OrganizationAvgAggregateOutputType ? OrganizationAvgAggregateOutputType[P] : never
}
    
    

export type OrganizationSelect = {
  projectId?: boolean
  id?: boolean
  name?: boolean
  project?: boolean | ProjectArgs
  contributorAttributeValues?: boolean | FindManyContributorAttributeValueArgs
  persons?: boolean | FindManyPersonArgs
}

export type OrganizationInclude = {
  project?: boolean | ProjectArgs
  contributorAttributeValues?: boolean | FindManyContributorAttributeValueArgs
  persons?: boolean | FindManyPersonArgs
}

export type OrganizationGetPayload<
  S extends boolean | null | undefined | OrganizationArgs,
  U = keyof S
> = S extends true
  ? Organization
  : S extends undefined
  ? never
  : S extends OrganizationArgs | FindManyOrganizationArgs
  ? 'include' extends U
    ? Organization  & {
      [P in TrueKeys<S['include']>]:
      P extends 'project'
      ? ProjectGetPayload<S['include'][P]> :
      P extends 'contributorAttributeValues'
      ? Array<ContributorAttributeValueGetPayload<S['include'][P]>> :
      P extends 'persons'
      ? Array<PersonGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Organization ? Organization[P]
: 
      P extends 'project'
      ? ProjectGetPayload<S['select'][P]> :
      P extends 'contributorAttributeValues'
      ? Array<ContributorAttributeValueGetPayload<S['select'][P]>> :
      P extends 'persons'
      ? Array<PersonGetPayload<S['select'][P]>> : never
    }
  : Organization
: Organization


export interface OrganizationDelegate {
  /**
   * Find zero or one Organization that matches the filter.
   * @param {FindOneOrganizationArgs} args - Arguments to find a Organization
   * @example
   * // Get one Organization
   * const organization = await prisma.organization.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOrganizationArgs>(
    args: Subset<T, FindOneOrganizationArgs>
  ): CheckSelect<T, Prisma__OrganizationClient<Organization | null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | null>>
  /**
   * Find the first Organization that matches the filter.
   * @param {FindFirstOrganizationArgs} args - Arguments to find a Organization
   * @example
   * // Get one Organization
   * const organization = await prisma.organization.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstOrganizationArgs>(
    args?: Subset<T, FindFirstOrganizationArgs>
  ): CheckSelect<T, Prisma__OrganizationClient<Organization | null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | null>>
  /**
   * Find zero or more Organizations that matches the filter.
   * @param {FindManyOrganizationArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Organizations
   * const organizations = await prisma.organization.findMany()
   * 
   * // Get first 10 Organizations
   * const organizations = await prisma.organization.findMany({ take: 10 })
   * 
   * // Only select the `projectId`
   * const organizationWithProjectIdOnly = await prisma.organization.findMany({ select: { projectId: true } })
   * 
  **/
  findMany<T extends FindManyOrganizationArgs>(
    args?: Subset<T, FindManyOrganizationArgs>
  ): CheckSelect<T, Promise<Array<Organization>>, Promise<Array<OrganizationGetPayload<T>>>>
  /**
   * Create a Organization.
   * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
   * @example
   * // Create one Organization
   * const Organization = await prisma.organization.create({
   *   data: {
   *     // ... data to create a Organization
   *   }
   * })
   * 
  **/
  create<T extends OrganizationCreateArgs>(
    args: Subset<T, OrganizationCreateArgs>
  ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>
  /**
   * Delete a Organization.
   * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
   * @example
   * // Delete one Organization
   * const Organization = await prisma.organization.delete({
   *   where: {
   *     // ... filter to delete one Organization
   *   }
   * })
   * 
  **/
  delete<T extends OrganizationDeleteArgs>(
    args: Subset<T, OrganizationDeleteArgs>
  ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>
  /**
   * Update one Organization.
   * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
   * @example
   * // Update one Organization
   * const organization = await prisma.organization.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OrganizationUpdateArgs>(
    args: Subset<T, OrganizationUpdateArgs>
  ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>
  /**
   * Delete zero or more Organizations.
   * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
   * @example
   * // Delete a few Organizations
   * const { count } = await prisma.organization.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OrganizationDeleteManyArgs>(
    args: Subset<T, OrganizationDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Organizations.
   * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Organizations
   * const organization = await prisma.organization.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OrganizationUpdateManyArgs>(
    args: Subset<T, OrganizationUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Organization.
   * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
   * @example
   * // Update or create a Organization
   * const organization = await prisma.organization.upsert({
   *   create: {
   *     // ... data to create a Organization
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Organization we want to update
   *   }
   * })
  **/
  upsert<T extends OrganizationUpsertArgs>(
    args: Subset<T, OrganizationUpsertArgs>
  ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOrganizationArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOrganizationArgs>(args: Subset<T, AggregateOrganizationArgs>): Promise<GetOrganizationAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Organization.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OrganizationClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>;

  contributorAttributeValues<T extends FindManyContributorAttributeValueArgs = {}>(args?: Subset<T, FindManyContributorAttributeValueArgs>): CheckSelect<T, Promise<Array<ContributorAttributeValue>>, Promise<Array<ContributorAttributeValueGetPayload<T>>>>;

  persons<T extends FindManyPersonArgs = {}>(args?: Subset<T, FindManyPersonArgs>): CheckSelect<T, Promise<Array<Person>>, Promise<Array<PersonGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Organization findOne
 */
export type FindOneOrganizationArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
  /**
   * Filter, which Organization to fetch.
  **/
  where: OrganizationWhereUniqueInput
}


/**
 * Organization findFirst
 */
export type FindFirstOrganizationArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
  /**
   * Filter, which Organization to fetch.
  **/
  where?: OrganizationWhereInput
  orderBy?: Enumerable<OrganizationOrderByInput> | OrganizationOrderByInput
  cursor?: OrganizationWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OrganizationDistinctFieldEnum>
}


/**
 * Organization findMany
 */
export type FindManyOrganizationArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
  /**
   * Filter, which Organizations to fetch.
  **/
  where?: OrganizationWhereInput
  /**
   * Determine the order of the Organizations to fetch.
  **/
  orderBy?: Enumerable<OrganizationOrderByInput> | OrganizationOrderByInput
  /**
   * Sets the position for listing Organizations.
  **/
  cursor?: OrganizationWhereUniqueInput
  /**
   * The number of Organizations to fetch. If negative number, it will take Organizations before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Organizations.
  **/
  skip?: number
  distinct?: Enumerable<OrganizationDistinctFieldEnum>
}


/**
 * Organization create
 */
export type OrganizationCreateArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
  /**
   * The data needed to create a Organization.
  **/
  data: OrganizationCreateInput
}


/**
 * Organization update
 */
export type OrganizationUpdateArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
  /**
   * The data needed to update a Organization.
  **/
  data: OrganizationUpdateInput
  /**
   * Choose, which Organization to update.
  **/
  where: OrganizationWhereUniqueInput
}


/**
 * Organization updateMany
 */
export type OrganizationUpdateManyArgs = {
  data: OrganizationUpdateManyMutationInput
  where?: OrganizationWhereInput
}


/**
 * Organization upsert
 */
export type OrganizationUpsertArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
  /**
   * The filter to search for the Organization to update in case it exists.
  **/
  where: OrganizationWhereUniqueInput
  /**
   * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
  **/
  create: OrganizationCreateInput
  /**
   * In case the Organization was found with the provided `where` argument, update it with this data.
  **/
  update: OrganizationUpdateInput
}


/**
 * Organization delete
 */
export type OrganizationDeleteArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
  /**
   * Filter which Organization to delete.
  **/
  where: OrganizationWhereUniqueInput
}


/**
 * Organization deleteMany
 */
export type OrganizationDeleteManyArgs = {
  where?: OrganizationWhereInput
}


/**
 * Organization without action
 */
export type OrganizationArgs = {
  /**
   * Select specific fields to fetch from the Organization
  **/
  select?: OrganizationSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OrganizationInclude | null
}



/**
 * Model Person
 */

export type Person = {
  projectId: number
  id: number
  name: string
  email: string
  organizationId: number
}


export type AggregatePerson = {
  count: number
  avg: PersonAvgAggregateOutputType | null
  sum: PersonSumAggregateOutputType | null
  min: PersonMinAggregateOutputType | null
  max: PersonMaxAggregateOutputType | null
}

export type PersonAvgAggregateOutputType = {
  projectId: number
  id: number
  organizationId: number
}

export type PersonSumAggregateOutputType = {
  projectId: number
  id: number
  organizationId: number
}

export type PersonMinAggregateOutputType = {
  projectId: number
  id: number
  organizationId: number
}

export type PersonMaxAggregateOutputType = {
  projectId: number
  id: number
  organizationId: number
}


export type PersonAvgAggregateInputType = {
  projectId?: true
  id?: true
  organizationId?: true
}

export type PersonSumAggregateInputType = {
  projectId?: true
  id?: true
  organizationId?: true
}

export type PersonMinAggregateInputType = {
  projectId?: true
  id?: true
  organizationId?: true
}

export type PersonMaxAggregateInputType = {
  projectId?: true
  id?: true
  organizationId?: true
}

export type AggregatePersonArgs = {
  where?: PersonWhereInput
  orderBy?: Enumerable<PersonOrderByInput> | PersonOrderByInput
  cursor?: PersonWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PersonDistinctFieldEnum>
  count?: true
  avg?: PersonAvgAggregateInputType
  sum?: PersonSumAggregateInputType
  min?: PersonMinAggregateInputType
  max?: PersonMaxAggregateInputType
}

export type GetPersonAggregateType<T extends AggregatePersonArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetPersonAggregateScalarType<T[P]>
}

export type GetPersonAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof PersonAvgAggregateOutputType ? PersonAvgAggregateOutputType[P] : never
}
    
    

export type PersonSelect = {
  projectId?: boolean
  id?: boolean
  name?: boolean
  email?: boolean
  organizationId?: boolean
  organization?: boolean | OrganizationArgs
  project?: boolean | ProjectArgs
  accounts?: boolean | FindManyAccountArgs
  contributorAttributeValues?: boolean | FindManyContributorAttributeValueArgs
  message_Message_requesterIdToPersons?: boolean | FindManyMessageArgs
  message_Message_submitterIdToPersons?: boolean | FindManyMessageArgs
  subMessages?: boolean | FindManySubMessageArgs
}

export type PersonInclude = {
  organization?: boolean | OrganizationArgs
  project?: boolean | ProjectArgs
  accounts?: boolean | FindManyAccountArgs
  contributorAttributeValues?: boolean | FindManyContributorAttributeValueArgs
  message_Message_requesterIdToPersons?: boolean | FindManyMessageArgs
  message_Message_submitterIdToPersons?: boolean | FindManyMessageArgs
  subMessages?: boolean | FindManySubMessageArgs
}

export type PersonGetPayload<
  S extends boolean | null | undefined | PersonArgs,
  U = keyof S
> = S extends true
  ? Person
  : S extends undefined
  ? never
  : S extends PersonArgs | FindManyPersonArgs
  ? 'include' extends U
    ? Person  & {
      [P in TrueKeys<S['include']>]:
      P extends 'organization'
      ? OrganizationGetPayload<S['include'][P]> :
      P extends 'project'
      ? ProjectGetPayload<S['include'][P]> :
      P extends 'accounts'
      ? Array<AccountGetPayload<S['include'][P]>> :
      P extends 'contributorAttributeValues'
      ? Array<ContributorAttributeValueGetPayload<S['include'][P]>> :
      P extends 'message_Message_requesterIdToPersons'
      ? Array<MessageGetPayload<S['include'][P]>> :
      P extends 'message_Message_submitterIdToPersons'
      ? Array<MessageGetPayload<S['include'][P]>> :
      P extends 'subMessages'
      ? Array<SubMessageGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Person ? Person[P]
: 
      P extends 'organization'
      ? OrganizationGetPayload<S['select'][P]> :
      P extends 'project'
      ? ProjectGetPayload<S['select'][P]> :
      P extends 'accounts'
      ? Array<AccountGetPayload<S['select'][P]>> :
      P extends 'contributorAttributeValues'
      ? Array<ContributorAttributeValueGetPayload<S['select'][P]>> :
      P extends 'message_Message_requesterIdToPersons'
      ? Array<MessageGetPayload<S['select'][P]>> :
      P extends 'message_Message_submitterIdToPersons'
      ? Array<MessageGetPayload<S['select'][P]>> :
      P extends 'subMessages'
      ? Array<SubMessageGetPayload<S['select'][P]>> : never
    }
  : Person
: Person


export interface PersonDelegate {
  /**
   * Find zero or one Person that matches the filter.
   * @param {FindOnePersonArgs} args - Arguments to find a Person
   * @example
   * // Get one Person
   * const person = await prisma.person.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnePersonArgs>(
    args: Subset<T, FindOnePersonArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>
  /**
   * Find the first Person that matches the filter.
   * @param {FindFirstPersonArgs} args - Arguments to find a Person
   * @example
   * // Get one Person
   * const person = await prisma.person.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstPersonArgs>(
    args?: Subset<T, FindFirstPersonArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>
  /**
   * Find zero or more People that matches the filter.
   * @param {FindManyPersonArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all People
   * const people = await prisma.person.findMany()
   * 
   * // Get first 10 People
   * const people = await prisma.person.findMany({ take: 10 })
   * 
   * // Only select the `projectId`
   * const personWithProjectIdOnly = await prisma.person.findMany({ select: { projectId: true } })
   * 
  **/
  findMany<T extends FindManyPersonArgs>(
    args?: Subset<T, FindManyPersonArgs>
  ): CheckSelect<T, Promise<Array<Person>>, Promise<Array<PersonGetPayload<T>>>>
  /**
   * Create a Person.
   * @param {PersonCreateArgs} args - Arguments to create a Person.
   * @example
   * // Create one Person
   * const Person = await prisma.person.create({
   *   data: {
   *     // ... data to create a Person
   *   }
   * })
   * 
  **/
  create<T extends PersonCreateArgs>(
    args: Subset<T, PersonCreateArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Delete a Person.
   * @param {PersonDeleteArgs} args - Arguments to delete one Person.
   * @example
   * // Delete one Person
   * const Person = await prisma.person.delete({
   *   where: {
   *     // ... filter to delete one Person
   *   }
   * })
   * 
  **/
  delete<T extends PersonDeleteArgs>(
    args: Subset<T, PersonDeleteArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Update one Person.
   * @param {PersonUpdateArgs} args - Arguments to update one Person.
   * @example
   * // Update one Person
   * const person = await prisma.person.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends PersonUpdateArgs>(
    args: Subset<T, PersonUpdateArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Delete zero or more People.
   * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
   * @example
   * // Delete a few People
   * const { count } = await prisma.person.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends PersonDeleteManyArgs>(
    args: Subset<T, PersonDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more People.
   * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many People
   * const person = await prisma.person.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends PersonUpdateManyArgs>(
    args: Subset<T, PersonUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Person.
   * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
   * @example
   * // Update or create a Person
   * const person = await prisma.person.upsert({
   *   create: {
   *     // ... data to create a Person
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Person we want to update
   *   }
   * })
  **/
  upsert<T extends PersonUpsertArgs>(
    args: Subset<T, PersonUpsertArgs>
  ): CheckSelect<T, Prisma__PersonClient<Person>, Prisma__PersonClient<PersonGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyPersonArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregatePersonArgs>(args: Subset<T, AggregatePersonArgs>): Promise<GetPersonAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Person.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__PersonClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | null>, Prisma__OrganizationClient<OrganizationGetPayload<T> | null>>;

  project<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>;

  accounts<T extends FindManyAccountArgs = {}>(args?: Subset<T, FindManyAccountArgs>): CheckSelect<T, Promise<Array<Account>>, Promise<Array<AccountGetPayload<T>>>>;

  contributorAttributeValues<T extends FindManyContributorAttributeValueArgs = {}>(args?: Subset<T, FindManyContributorAttributeValueArgs>): CheckSelect<T, Promise<Array<ContributorAttributeValue>>, Promise<Array<ContributorAttributeValueGetPayload<T>>>>;

  message_Message_requesterIdToPersons<T extends FindManyMessageArgs = {}>(args?: Subset<T, FindManyMessageArgs>): CheckSelect<T, Promise<Array<Message>>, Promise<Array<MessageGetPayload<T>>>>;

  message_Message_submitterIdToPersons<T extends FindManyMessageArgs = {}>(args?: Subset<T, FindManyMessageArgs>): CheckSelect<T, Promise<Array<Message>>, Promise<Array<MessageGetPayload<T>>>>;

  subMessages<T extends FindManySubMessageArgs = {}>(args?: Subset<T, FindManySubMessageArgs>): CheckSelect<T, Promise<Array<SubMessage>>, Promise<Array<SubMessageGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Person findOne
 */
export type FindOnePersonArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * Filter, which Person to fetch.
  **/
  where: PersonWhereUniqueInput
}


/**
 * Person findFirst
 */
export type FindFirstPersonArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * Filter, which Person to fetch.
  **/
  where?: PersonWhereInput
  orderBy?: Enumerable<PersonOrderByInput> | PersonOrderByInput
  cursor?: PersonWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PersonDistinctFieldEnum>
}


/**
 * Person findMany
 */
export type FindManyPersonArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * Filter, which People to fetch.
  **/
  where?: PersonWhereInput
  /**
   * Determine the order of the People to fetch.
  **/
  orderBy?: Enumerable<PersonOrderByInput> | PersonOrderByInput
  /**
   * Sets the position for listing People.
  **/
  cursor?: PersonWhereUniqueInput
  /**
   * The number of People to fetch. If negative number, it will take People before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` People.
  **/
  skip?: number
  distinct?: Enumerable<PersonDistinctFieldEnum>
}


/**
 * Person create
 */
export type PersonCreateArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * The data needed to create a Person.
  **/
  data: PersonCreateInput
}


/**
 * Person update
 */
export type PersonUpdateArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * The data needed to update a Person.
  **/
  data: PersonUpdateInput
  /**
   * Choose, which Person to update.
  **/
  where: PersonWhereUniqueInput
}


/**
 * Person updateMany
 */
export type PersonUpdateManyArgs = {
  data: PersonUpdateManyMutationInput
  where?: PersonWhereInput
}


/**
 * Person upsert
 */
export type PersonUpsertArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * The filter to search for the Person to update in case it exists.
  **/
  where: PersonWhereUniqueInput
  /**
   * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
  **/
  create: PersonCreateInput
  /**
   * In case the Person was found with the provided `where` argument, update it with this data.
  **/
  update: PersonUpdateInput
}


/**
 * Person delete
 */
export type PersonDeleteArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
  /**
   * Filter which Person to delete.
  **/
  where: PersonWhereUniqueInput
}


/**
 * Person deleteMany
 */
export type PersonDeleteManyArgs = {
  where?: PersonWhereInput
}


/**
 * Person without action
 */
export type PersonArgs = {
  /**
   * Select specific fields to fetch from the Person
  **/
  select?: PersonSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PersonInclude | null
}



/**
 * Model Project
 */

export type Project = {
  id: number
  name: string
}


export type AggregateProject = {
  count: number
  avg: ProjectAvgAggregateOutputType | null
  sum: ProjectSumAggregateOutputType | null
  min: ProjectMinAggregateOutputType | null
  max: ProjectMaxAggregateOutputType | null
}

export type ProjectAvgAggregateOutputType = {
  id: number
}

export type ProjectSumAggregateOutputType = {
  id: number
}

export type ProjectMinAggregateOutputType = {
  id: number
}

export type ProjectMaxAggregateOutputType = {
  id: number
}


export type ProjectAvgAggregateInputType = {
  id?: true
}

export type ProjectSumAggregateInputType = {
  id?: true
}

export type ProjectMinAggregateInputType = {
  id?: true
}

export type ProjectMaxAggregateInputType = {
  id?: true
}

export type AggregateProjectArgs = {
  where?: ProjectWhereInput
  orderBy?: Enumerable<ProjectOrderByInput> | ProjectOrderByInput
  cursor?: ProjectWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ProjectDistinctFieldEnum>
  count?: true
  avg?: ProjectAvgAggregateInputType
  sum?: ProjectSumAggregateInputType
  min?: ProjectMinAggregateInputType
  max?: ProjectMaxAggregateInputType
}

export type GetProjectAggregateType<T extends AggregateProjectArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetProjectAggregateScalarType<T[P]>
}

export type GetProjectAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ProjectAvgAggregateOutputType ? ProjectAvgAggregateOutputType[P] : never
}
    
    

export type ProjectSelect = {
  id?: boolean
  name?: boolean
  accounts?: boolean | FindManyAccountArgs
  chunks?: boolean | FindManyChunkArgs
  contributorAttributes?: boolean | FindManyContributorAttributeArgs
  discoverys?: boolean | FindManyDiscoveryArgs
  messages?: boolean | FindManyMessageArgs
  organizations?: boolean | FindManyOrganizationArgs
  persons?: boolean | FindManyPersonArgs
}

export type ProjectInclude = {
  accounts?: boolean | FindManyAccountArgs
  chunks?: boolean | FindManyChunkArgs
  contributorAttributes?: boolean | FindManyContributorAttributeArgs
  discoverys?: boolean | FindManyDiscoveryArgs
  messages?: boolean | FindManyMessageArgs
  organizations?: boolean | FindManyOrganizationArgs
  persons?: boolean | FindManyPersonArgs
}

export type ProjectGetPayload<
  S extends boolean | null | undefined | ProjectArgs,
  U = keyof S
> = S extends true
  ? Project
  : S extends undefined
  ? never
  : S extends ProjectArgs | FindManyProjectArgs
  ? 'include' extends U
    ? Project  & {
      [P in TrueKeys<S['include']>]:
      P extends 'accounts'
      ? Array<AccountGetPayload<S['include'][P]>> :
      P extends 'chunks'
      ? Array<ChunkGetPayload<S['include'][P]>> :
      P extends 'contributorAttributes'
      ? Array<ContributorAttributeGetPayload<S['include'][P]>> :
      P extends 'discoverys'
      ? Array<DiscoveryGetPayload<S['include'][P]>> :
      P extends 'messages'
      ? Array<MessageGetPayload<S['include'][P]>> :
      P extends 'organizations'
      ? Array<OrganizationGetPayload<S['include'][P]>> :
      P extends 'persons'
      ? Array<PersonGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Project ? Project[P]
: 
      P extends 'accounts'
      ? Array<AccountGetPayload<S['select'][P]>> :
      P extends 'chunks'
      ? Array<ChunkGetPayload<S['select'][P]>> :
      P extends 'contributorAttributes'
      ? Array<ContributorAttributeGetPayload<S['select'][P]>> :
      P extends 'discoverys'
      ? Array<DiscoveryGetPayload<S['select'][P]>> :
      P extends 'messages'
      ? Array<MessageGetPayload<S['select'][P]>> :
      P extends 'organizations'
      ? Array<OrganizationGetPayload<S['select'][P]>> :
      P extends 'persons'
      ? Array<PersonGetPayload<S['select'][P]>> : never
    }
  : Project
: Project


export interface ProjectDelegate {
  /**
   * Find zero or one Project that matches the filter.
   * @param {FindOneProjectArgs} args - Arguments to find a Project
   * @example
   * // Get one Project
   * const project = await prisma.project.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneProjectArgs>(
    args: Subset<T, FindOneProjectArgs>
  ): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>
  /**
   * Find the first Project that matches the filter.
   * @param {FindFirstProjectArgs} args - Arguments to find a Project
   * @example
   * // Get one Project
   * const project = await prisma.project.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstProjectArgs>(
    args?: Subset<T, FindFirstProjectArgs>
  ): CheckSelect<T, Prisma__ProjectClient<Project | null>, Prisma__ProjectClient<ProjectGetPayload<T> | null>>
  /**
   * Find zero or more Projects that matches the filter.
   * @param {FindManyProjectArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Projects
   * const projects = await prisma.project.findMany()
   * 
   * // Get first 10 Projects
   * const projects = await prisma.project.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyProjectArgs>(
    args?: Subset<T, FindManyProjectArgs>
  ): CheckSelect<T, Promise<Array<Project>>, Promise<Array<ProjectGetPayload<T>>>>
  /**
   * Create a Project.
   * @param {ProjectCreateArgs} args - Arguments to create a Project.
   * @example
   * // Create one Project
   * const Project = await prisma.project.create({
   *   data: {
   *     // ... data to create a Project
   *   }
   * })
   * 
  **/
  create<T extends ProjectCreateArgs>(
    args: Subset<T, ProjectCreateArgs>
  ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>
  /**
   * Delete a Project.
   * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
   * @example
   * // Delete one Project
   * const Project = await prisma.project.delete({
   *   where: {
   *     // ... filter to delete one Project
   *   }
   * })
   * 
  **/
  delete<T extends ProjectDeleteArgs>(
    args: Subset<T, ProjectDeleteArgs>
  ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>
  /**
   * Update one Project.
   * @param {ProjectUpdateArgs} args - Arguments to update one Project.
   * @example
   * // Update one Project
   * const project = await prisma.project.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ProjectUpdateArgs>(
    args: Subset<T, ProjectUpdateArgs>
  ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>
  /**
   * Delete zero or more Projects.
   * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
   * @example
   * // Delete a few Projects
   * const { count } = await prisma.project.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ProjectDeleteManyArgs>(
    args: Subset<T, ProjectDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Projects.
   * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Projects
   * const project = await prisma.project.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ProjectUpdateManyArgs>(
    args: Subset<T, ProjectUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Project.
   * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
   * @example
   * // Update or create a Project
   * const project = await prisma.project.upsert({
   *   create: {
   *     // ... data to create a Project
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Project we want to update
   *   }
   * })
  **/
  upsert<T extends ProjectUpsertArgs>(
    args: Subset<T, ProjectUpsertArgs>
  ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyProjectArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateProjectArgs>(args: Subset<T, AggregateProjectArgs>): Promise<GetProjectAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Project.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ProjectClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  accounts<T extends FindManyAccountArgs = {}>(args?: Subset<T, FindManyAccountArgs>): CheckSelect<T, Promise<Array<Account>>, Promise<Array<AccountGetPayload<T>>>>;

  chunks<T extends FindManyChunkArgs = {}>(args?: Subset<T, FindManyChunkArgs>): CheckSelect<T, Promise<Array<Chunk>>, Promise<Array<ChunkGetPayload<T>>>>;

  contributorAttributes<T extends FindManyContributorAttributeArgs = {}>(args?: Subset<T, FindManyContributorAttributeArgs>): CheckSelect<T, Promise<Array<ContributorAttribute>>, Promise<Array<ContributorAttributeGetPayload<T>>>>;

  discoverys<T extends FindManyDiscoveryArgs = {}>(args?: Subset<T, FindManyDiscoveryArgs>): CheckSelect<T, Promise<Array<Discovery>>, Promise<Array<DiscoveryGetPayload<T>>>>;

  messages<T extends FindManyMessageArgs = {}>(args?: Subset<T, FindManyMessageArgs>): CheckSelect<T, Promise<Array<Message>>, Promise<Array<MessageGetPayload<T>>>>;

  organizations<T extends FindManyOrganizationArgs = {}>(args?: Subset<T, FindManyOrganizationArgs>): CheckSelect<T, Promise<Array<Organization>>, Promise<Array<OrganizationGetPayload<T>>>>;

  persons<T extends FindManyPersonArgs = {}>(args?: Subset<T, FindManyPersonArgs>): CheckSelect<T, Promise<Array<Person>>, Promise<Array<PersonGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Project findOne
 */
export type FindOneProjectArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
  /**
   * Filter, which Project to fetch.
  **/
  where: ProjectWhereUniqueInput
}


/**
 * Project findFirst
 */
export type FindFirstProjectArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
  /**
   * Filter, which Project to fetch.
  **/
  where?: ProjectWhereInput
  orderBy?: Enumerable<ProjectOrderByInput> | ProjectOrderByInput
  cursor?: ProjectWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ProjectDistinctFieldEnum>
}


/**
 * Project findMany
 */
export type FindManyProjectArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
  /**
   * Filter, which Projects to fetch.
  **/
  where?: ProjectWhereInput
  /**
   * Determine the order of the Projects to fetch.
  **/
  orderBy?: Enumerable<ProjectOrderByInput> | ProjectOrderByInput
  /**
   * Sets the position for listing Projects.
  **/
  cursor?: ProjectWhereUniqueInput
  /**
   * The number of Projects to fetch. If negative number, it will take Projects before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Projects.
  **/
  skip?: number
  distinct?: Enumerable<ProjectDistinctFieldEnum>
}


/**
 * Project create
 */
export type ProjectCreateArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
  /**
   * The data needed to create a Project.
  **/
  data: ProjectCreateInput
}


/**
 * Project update
 */
export type ProjectUpdateArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
  /**
   * The data needed to update a Project.
  **/
  data: ProjectUpdateInput
  /**
   * Choose, which Project to update.
  **/
  where: ProjectWhereUniqueInput
}


/**
 * Project updateMany
 */
export type ProjectUpdateManyArgs = {
  data: ProjectUpdateManyMutationInput
  where?: ProjectWhereInput
}


/**
 * Project upsert
 */
export type ProjectUpsertArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
  /**
   * The filter to search for the Project to update in case it exists.
  **/
  where: ProjectWhereUniqueInput
  /**
   * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
  **/
  create: ProjectCreateInput
  /**
   * In case the Project was found with the provided `where` argument, update it with this data.
  **/
  update: ProjectUpdateInput
}


/**
 * Project delete
 */
export type ProjectDeleteArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
  /**
   * Filter which Project to delete.
  **/
  where: ProjectWhereUniqueInput
}


/**
 * Project deleteMany
 */
export type ProjectDeleteManyArgs = {
  where?: ProjectWhereInput
}


/**
 * Project without action
 */
export type ProjectArgs = {
  /**
   * Select specific fields to fetch from the Project
  **/
  select?: ProjectSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ProjectInclude | null
}



/**
 * Model SubMessage
 */

export type SubMessage = {
  id: number
  submitterId: number
  content: string
  messageId: number
}


export type AggregateSubMessage = {
  count: number
  avg: SubMessageAvgAggregateOutputType | null
  sum: SubMessageSumAggregateOutputType | null
  min: SubMessageMinAggregateOutputType | null
  max: SubMessageMaxAggregateOutputType | null
}

export type SubMessageAvgAggregateOutputType = {
  id: number
  submitterId: number
  messageId: number
}

export type SubMessageSumAggregateOutputType = {
  id: number
  submitterId: number
  messageId: number
}

export type SubMessageMinAggregateOutputType = {
  id: number
  submitterId: number
  messageId: number
}

export type SubMessageMaxAggregateOutputType = {
  id: number
  submitterId: number
  messageId: number
}


export type SubMessageAvgAggregateInputType = {
  id?: true
  submitterId?: true
  messageId?: true
}

export type SubMessageSumAggregateInputType = {
  id?: true
  submitterId?: true
  messageId?: true
}

export type SubMessageMinAggregateInputType = {
  id?: true
  submitterId?: true
  messageId?: true
}

export type SubMessageMaxAggregateInputType = {
  id?: true
  submitterId?: true
  messageId?: true
}

export type AggregateSubMessageArgs = {
  where?: SubMessageWhereInput
  orderBy?: Enumerable<SubMessageOrderByInput> | SubMessageOrderByInput
  cursor?: SubMessageWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SubMessageDistinctFieldEnum>
  count?: true
  avg?: SubMessageAvgAggregateInputType
  sum?: SubMessageSumAggregateInputType
  min?: SubMessageMinAggregateInputType
  max?: SubMessageMaxAggregateInputType
}

export type GetSubMessageAggregateType<T extends AggregateSubMessageArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetSubMessageAggregateScalarType<T[P]>
}

export type GetSubMessageAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof SubMessageAvgAggregateOutputType ? SubMessageAvgAggregateOutputType[P] : never
}
    
    

export type SubMessageSelect = {
  id?: boolean
  submitterId?: boolean
  content?: boolean
  messageId?: boolean
  message?: boolean | MessageArgs
  person?: boolean | PersonArgs
}

export type SubMessageInclude = {
  message?: boolean | MessageArgs
  person?: boolean | PersonArgs
}

export type SubMessageGetPayload<
  S extends boolean | null | undefined | SubMessageArgs,
  U = keyof S
> = S extends true
  ? SubMessage
  : S extends undefined
  ? never
  : S extends SubMessageArgs | FindManySubMessageArgs
  ? 'include' extends U
    ? SubMessage  & {
      [P in TrueKeys<S['include']>]:
      P extends 'message'
      ? MessageGetPayload<S['include'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof SubMessage ? SubMessage[P]
: 
      P extends 'message'
      ? MessageGetPayload<S['select'][P]> :
      P extends 'person'
      ? PersonGetPayload<S['select'][P]> : never
    }
  : SubMessage
: SubMessage


export interface SubMessageDelegate {
  /**
   * Find zero or one SubMessage that matches the filter.
   * @param {FindOneSubMessageArgs} args - Arguments to find a SubMessage
   * @example
   * // Get one SubMessage
   * const subMessage = await prisma.subMessage.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneSubMessageArgs>(
    args: Subset<T, FindOneSubMessageArgs>
  ): CheckSelect<T, Prisma__SubMessageClient<SubMessage | null>, Prisma__SubMessageClient<SubMessageGetPayload<T> | null>>
  /**
   * Find the first SubMessage that matches the filter.
   * @param {FindFirstSubMessageArgs} args - Arguments to find a SubMessage
   * @example
   * // Get one SubMessage
   * const subMessage = await prisma.subMessage.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstSubMessageArgs>(
    args?: Subset<T, FindFirstSubMessageArgs>
  ): CheckSelect<T, Prisma__SubMessageClient<SubMessage | null>, Prisma__SubMessageClient<SubMessageGetPayload<T> | null>>
  /**
   * Find zero or more SubMessages that matches the filter.
   * @param {FindManySubMessageArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all SubMessages
   * const subMessages = await prisma.subMessage.findMany()
   * 
   * // Get first 10 SubMessages
   * const subMessages = await prisma.subMessage.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const subMessageWithIdOnly = await prisma.subMessage.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManySubMessageArgs>(
    args?: Subset<T, FindManySubMessageArgs>
  ): CheckSelect<T, Promise<Array<SubMessage>>, Promise<Array<SubMessageGetPayload<T>>>>
  /**
   * Create a SubMessage.
   * @param {SubMessageCreateArgs} args - Arguments to create a SubMessage.
   * @example
   * // Create one SubMessage
   * const SubMessage = await prisma.subMessage.create({
   *   data: {
   *     // ... data to create a SubMessage
   *   }
   * })
   * 
  **/
  create<T extends SubMessageCreateArgs>(
    args: Subset<T, SubMessageCreateArgs>
  ): CheckSelect<T, Prisma__SubMessageClient<SubMessage>, Prisma__SubMessageClient<SubMessageGetPayload<T>>>
  /**
   * Delete a SubMessage.
   * @param {SubMessageDeleteArgs} args - Arguments to delete one SubMessage.
   * @example
   * // Delete one SubMessage
   * const SubMessage = await prisma.subMessage.delete({
   *   where: {
   *     // ... filter to delete one SubMessage
   *   }
   * })
   * 
  **/
  delete<T extends SubMessageDeleteArgs>(
    args: Subset<T, SubMessageDeleteArgs>
  ): CheckSelect<T, Prisma__SubMessageClient<SubMessage>, Prisma__SubMessageClient<SubMessageGetPayload<T>>>
  /**
   * Update one SubMessage.
   * @param {SubMessageUpdateArgs} args - Arguments to update one SubMessage.
   * @example
   * // Update one SubMessage
   * const subMessage = await prisma.subMessage.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends SubMessageUpdateArgs>(
    args: Subset<T, SubMessageUpdateArgs>
  ): CheckSelect<T, Prisma__SubMessageClient<SubMessage>, Prisma__SubMessageClient<SubMessageGetPayload<T>>>
  /**
   * Delete zero or more SubMessages.
   * @param {SubMessageDeleteManyArgs} args - Arguments to filter SubMessages to delete.
   * @example
   * // Delete a few SubMessages
   * const { count } = await prisma.subMessage.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends SubMessageDeleteManyArgs>(
    args: Subset<T, SubMessageDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more SubMessages.
   * @param {SubMessageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many SubMessages
   * const subMessage = await prisma.subMessage.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends SubMessageUpdateManyArgs>(
    args: Subset<T, SubMessageUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one SubMessage.
   * @param {SubMessageUpsertArgs} args - Arguments to update or create a SubMessage.
   * @example
   * // Update or create a SubMessage
   * const subMessage = await prisma.subMessage.upsert({
   *   create: {
   *     // ... data to create a SubMessage
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the SubMessage we want to update
   *   }
   * })
  **/
  upsert<T extends SubMessageUpsertArgs>(
    args: Subset<T, SubMessageUpsertArgs>
  ): CheckSelect<T, Prisma__SubMessageClient<SubMessage>, Prisma__SubMessageClient<SubMessageGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManySubMessageArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateSubMessageArgs>(args: Subset<T, AggregateSubMessageArgs>): Promise<GetSubMessageAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for SubMessage.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__SubMessageClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  message<T extends MessageArgs = {}>(args?: Subset<T, MessageArgs>): CheckSelect<T, Prisma__MessageClient<Message | null>, Prisma__MessageClient<MessageGetPayload<T> | null>>;

  person<T extends PersonArgs = {}>(args?: Subset<T, PersonArgs>): CheckSelect<T, Prisma__PersonClient<Person | null>, Prisma__PersonClient<PersonGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * SubMessage findOne
 */
export type FindOneSubMessageArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
  /**
   * Filter, which SubMessage to fetch.
  **/
  where: SubMessageWhereUniqueInput
}


/**
 * SubMessage findFirst
 */
export type FindFirstSubMessageArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
  /**
   * Filter, which SubMessage to fetch.
  **/
  where?: SubMessageWhereInput
  orderBy?: Enumerable<SubMessageOrderByInput> | SubMessageOrderByInput
  cursor?: SubMessageWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<SubMessageDistinctFieldEnum>
}


/**
 * SubMessage findMany
 */
export type FindManySubMessageArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
  /**
   * Filter, which SubMessages to fetch.
  **/
  where?: SubMessageWhereInput
  /**
   * Determine the order of the SubMessages to fetch.
  **/
  orderBy?: Enumerable<SubMessageOrderByInput> | SubMessageOrderByInput
  /**
   * Sets the position for listing SubMessages.
  **/
  cursor?: SubMessageWhereUniqueInput
  /**
   * The number of SubMessages to fetch. If negative number, it will take SubMessages before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` SubMessages.
  **/
  skip?: number
  distinct?: Enumerable<SubMessageDistinctFieldEnum>
}


/**
 * SubMessage create
 */
export type SubMessageCreateArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
  /**
   * The data needed to create a SubMessage.
  **/
  data: SubMessageCreateInput
}


/**
 * SubMessage update
 */
export type SubMessageUpdateArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
  /**
   * The data needed to update a SubMessage.
  **/
  data: SubMessageUpdateInput
  /**
   * Choose, which SubMessage to update.
  **/
  where: SubMessageWhereUniqueInput
}


/**
 * SubMessage updateMany
 */
export type SubMessageUpdateManyArgs = {
  data: SubMessageUpdateManyMutationInput
  where?: SubMessageWhereInput
}


/**
 * SubMessage upsert
 */
export type SubMessageUpsertArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
  /**
   * The filter to search for the SubMessage to update in case it exists.
  **/
  where: SubMessageWhereUniqueInput
  /**
   * In case the SubMessage found by the `where` argument doesn't exist, create a new SubMessage with this data.
  **/
  create: SubMessageCreateInput
  /**
   * In case the SubMessage was found with the provided `where` argument, update it with this data.
  **/
  update: SubMessageUpdateInput
}


/**
 * SubMessage delete
 */
export type SubMessageDeleteArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
  /**
   * Filter which SubMessage to delete.
  **/
  where: SubMessageWhereUniqueInput
}


/**
 * SubMessage deleteMany
 */
export type SubMessageDeleteManyArgs = {
  where?: SubMessageWhereInput
}


/**
 * SubMessage without action
 */
export type SubMessageArgs = {
  /**
   * Select specific fields to fetch from the SubMessage
  **/
  select?: SubMessageSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: SubMessageInclude | null
}



/**
 * Model TextSelection
 */

export type TextSelection = {
  id: number
  offsetstart: number
  length: number
  submessagenumber: number
  content: string
  chunkId: number
}


export type AggregateTextSelection = {
  count: number
  avg: TextSelectionAvgAggregateOutputType | null
  sum: TextSelectionSumAggregateOutputType | null
  min: TextSelectionMinAggregateOutputType | null
  max: TextSelectionMaxAggregateOutputType | null
}

export type TextSelectionAvgAggregateOutputType = {
  id: number
  offsetstart: number
  length: number
  submessagenumber: number
  chunkId: number
}

export type TextSelectionSumAggregateOutputType = {
  id: number
  offsetstart: number
  length: number
  submessagenumber: number
  chunkId: number
}

export type TextSelectionMinAggregateOutputType = {
  id: number
  offsetstart: number
  length: number
  submessagenumber: number
  chunkId: number
}

export type TextSelectionMaxAggregateOutputType = {
  id: number
  offsetstart: number
  length: number
  submessagenumber: number
  chunkId: number
}


export type TextSelectionAvgAggregateInputType = {
  id?: true
  offsetstart?: true
  length?: true
  submessagenumber?: true
  chunkId?: true
}

export type TextSelectionSumAggregateInputType = {
  id?: true
  offsetstart?: true
  length?: true
  submessagenumber?: true
  chunkId?: true
}

export type TextSelectionMinAggregateInputType = {
  id?: true
  offsetstart?: true
  length?: true
  submessagenumber?: true
  chunkId?: true
}

export type TextSelectionMaxAggregateInputType = {
  id?: true
  offsetstart?: true
  length?: true
  submessagenumber?: true
  chunkId?: true
}

export type AggregateTextSelectionArgs = {
  where?: TextSelectionWhereInput
  orderBy?: Enumerable<TextSelectionOrderByInput> | TextSelectionOrderByInput
  cursor?: TextSelectionWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<TextSelectionDistinctFieldEnum>
  count?: true
  avg?: TextSelectionAvgAggregateInputType
  sum?: TextSelectionSumAggregateInputType
  min?: TextSelectionMinAggregateInputType
  max?: TextSelectionMaxAggregateInputType
}

export type GetTextSelectionAggregateType<T extends AggregateTextSelectionArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetTextSelectionAggregateScalarType<T[P]>
}

export type GetTextSelectionAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof TextSelectionAvgAggregateOutputType ? TextSelectionAvgAggregateOutputType[P] : never
}
    
    

export type TextSelectionSelect = {
  id?: boolean
  offsetstart?: boolean
  length?: boolean
  submessagenumber?: boolean
  content?: boolean
  chunkId?: boolean
  chunk?: boolean | ChunkArgs
}

export type TextSelectionInclude = {
  chunk?: boolean | ChunkArgs
}

export type TextSelectionGetPayload<
  S extends boolean | null | undefined | TextSelectionArgs,
  U = keyof S
> = S extends true
  ? TextSelection
  : S extends undefined
  ? never
  : S extends TextSelectionArgs | FindManyTextSelectionArgs
  ? 'include' extends U
    ? TextSelection  & {
      [P in TrueKeys<S['include']>]:
      P extends 'chunk'
      ? ChunkGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof TextSelection ? TextSelection[P]
: 
      P extends 'chunk'
      ? ChunkGetPayload<S['select'][P]> : never
    }
  : TextSelection
: TextSelection


export interface TextSelectionDelegate {
  /**
   * Find zero or one TextSelection that matches the filter.
   * @param {FindOneTextSelectionArgs} args - Arguments to find a TextSelection
   * @example
   * // Get one TextSelection
   * const textSelection = await prisma.textSelection.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneTextSelectionArgs>(
    args: Subset<T, FindOneTextSelectionArgs>
  ): CheckSelect<T, Prisma__TextSelectionClient<TextSelection | null>, Prisma__TextSelectionClient<TextSelectionGetPayload<T> | null>>
  /**
   * Find the first TextSelection that matches the filter.
   * @param {FindFirstTextSelectionArgs} args - Arguments to find a TextSelection
   * @example
   * // Get one TextSelection
   * const textSelection = await prisma.textSelection.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstTextSelectionArgs>(
    args?: Subset<T, FindFirstTextSelectionArgs>
  ): CheckSelect<T, Prisma__TextSelectionClient<TextSelection | null>, Prisma__TextSelectionClient<TextSelectionGetPayload<T> | null>>
  /**
   * Find zero or more TextSelections that matches the filter.
   * @param {FindManyTextSelectionArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all TextSelections
   * const textSelections = await prisma.textSelection.findMany()
   * 
   * // Get first 10 TextSelections
   * const textSelections = await prisma.textSelection.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const textSelectionWithIdOnly = await prisma.textSelection.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyTextSelectionArgs>(
    args?: Subset<T, FindManyTextSelectionArgs>
  ): CheckSelect<T, Promise<Array<TextSelection>>, Promise<Array<TextSelectionGetPayload<T>>>>
  /**
   * Create a TextSelection.
   * @param {TextSelectionCreateArgs} args - Arguments to create a TextSelection.
   * @example
   * // Create one TextSelection
   * const TextSelection = await prisma.textSelection.create({
   *   data: {
   *     // ... data to create a TextSelection
   *   }
   * })
   * 
  **/
  create<T extends TextSelectionCreateArgs>(
    args: Subset<T, TextSelectionCreateArgs>
  ): CheckSelect<T, Prisma__TextSelectionClient<TextSelection>, Prisma__TextSelectionClient<TextSelectionGetPayload<T>>>
  /**
   * Delete a TextSelection.
   * @param {TextSelectionDeleteArgs} args - Arguments to delete one TextSelection.
   * @example
   * // Delete one TextSelection
   * const TextSelection = await prisma.textSelection.delete({
   *   where: {
   *     // ... filter to delete one TextSelection
   *   }
   * })
   * 
  **/
  delete<T extends TextSelectionDeleteArgs>(
    args: Subset<T, TextSelectionDeleteArgs>
  ): CheckSelect<T, Prisma__TextSelectionClient<TextSelection>, Prisma__TextSelectionClient<TextSelectionGetPayload<T>>>
  /**
   * Update one TextSelection.
   * @param {TextSelectionUpdateArgs} args - Arguments to update one TextSelection.
   * @example
   * // Update one TextSelection
   * const textSelection = await prisma.textSelection.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends TextSelectionUpdateArgs>(
    args: Subset<T, TextSelectionUpdateArgs>
  ): CheckSelect<T, Prisma__TextSelectionClient<TextSelection>, Prisma__TextSelectionClient<TextSelectionGetPayload<T>>>
  /**
   * Delete zero or more TextSelections.
   * @param {TextSelectionDeleteManyArgs} args - Arguments to filter TextSelections to delete.
   * @example
   * // Delete a few TextSelections
   * const { count } = await prisma.textSelection.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends TextSelectionDeleteManyArgs>(
    args: Subset<T, TextSelectionDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more TextSelections.
   * @param {TextSelectionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many TextSelections
   * const textSelection = await prisma.textSelection.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends TextSelectionUpdateManyArgs>(
    args: Subset<T, TextSelectionUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one TextSelection.
   * @param {TextSelectionUpsertArgs} args - Arguments to update or create a TextSelection.
   * @example
   * // Update or create a TextSelection
   * const textSelection = await prisma.textSelection.upsert({
   *   create: {
   *     // ... data to create a TextSelection
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the TextSelection we want to update
   *   }
   * })
  **/
  upsert<T extends TextSelectionUpsertArgs>(
    args: Subset<T, TextSelectionUpsertArgs>
  ): CheckSelect<T, Prisma__TextSelectionClient<TextSelection>, Prisma__TextSelectionClient<TextSelectionGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyTextSelectionArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateTextSelectionArgs>(args: Subset<T, AggregateTextSelectionArgs>): Promise<GetTextSelectionAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for TextSelection.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__TextSelectionClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  chunk<T extends ChunkArgs = {}>(args?: Subset<T, ChunkArgs>): CheckSelect<T, Prisma__ChunkClient<Chunk | null>, Prisma__ChunkClient<ChunkGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * TextSelection findOne
 */
export type FindOneTextSelectionArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
  /**
   * Filter, which TextSelection to fetch.
  **/
  where: TextSelectionWhereUniqueInput
}


/**
 * TextSelection findFirst
 */
export type FindFirstTextSelectionArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
  /**
   * Filter, which TextSelection to fetch.
  **/
  where?: TextSelectionWhereInput
  orderBy?: Enumerable<TextSelectionOrderByInput> | TextSelectionOrderByInput
  cursor?: TextSelectionWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<TextSelectionDistinctFieldEnum>
}


/**
 * TextSelection findMany
 */
export type FindManyTextSelectionArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
  /**
   * Filter, which TextSelections to fetch.
  **/
  where?: TextSelectionWhereInput
  /**
   * Determine the order of the TextSelections to fetch.
  **/
  orderBy?: Enumerable<TextSelectionOrderByInput> | TextSelectionOrderByInput
  /**
   * Sets the position for listing TextSelections.
  **/
  cursor?: TextSelectionWhereUniqueInput
  /**
   * The number of TextSelections to fetch. If negative number, it will take TextSelections before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` TextSelections.
  **/
  skip?: number
  distinct?: Enumerable<TextSelectionDistinctFieldEnum>
}


/**
 * TextSelection create
 */
export type TextSelectionCreateArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
  /**
   * The data needed to create a TextSelection.
  **/
  data: TextSelectionCreateInput
}


/**
 * TextSelection update
 */
export type TextSelectionUpdateArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
  /**
   * The data needed to update a TextSelection.
  **/
  data: TextSelectionUpdateInput
  /**
   * Choose, which TextSelection to update.
  **/
  where: TextSelectionWhereUniqueInput
}


/**
 * TextSelection updateMany
 */
export type TextSelectionUpdateManyArgs = {
  data: TextSelectionUpdateManyMutationInput
  where?: TextSelectionWhereInput
}


/**
 * TextSelection upsert
 */
export type TextSelectionUpsertArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
  /**
   * The filter to search for the TextSelection to update in case it exists.
  **/
  where: TextSelectionWhereUniqueInput
  /**
   * In case the TextSelection found by the `where` argument doesn't exist, create a new TextSelection with this data.
  **/
  create: TextSelectionCreateInput
  /**
   * In case the TextSelection was found with the provided `where` argument, update it with this data.
  **/
  update: TextSelectionUpdateInput
}


/**
 * TextSelection delete
 */
export type TextSelectionDeleteArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
  /**
   * Filter which TextSelection to delete.
  **/
  where: TextSelectionWhereUniqueInput
}


/**
 * TextSelection deleteMany
 */
export type TextSelectionDeleteManyArgs = {
  where?: TextSelectionWhereInput
}


/**
 * TextSelection without action
 */
export type TextSelectionArgs = {
  /**
   * Select specific fields to fetch from the TextSelection
  **/
  select?: TextSelectionSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TextSelectionInclude | null
}



/**
 * Deep Input Types
 */


export type AccountWhereInput = {
  AND?: AccountWhereInput | Enumerable<AccountWhereInput>
  OR?: AccountWhereInput | Enumerable<AccountWhereInput>
  NOT?: AccountWhereInput | Enumerable<AccountWhereInput>
  id?: IntFilter | number
  username?: StringFilter | string
  hashedPassword?: StringFilter | string
  personId?: IntFilter | number
  projectId?: IntFilter | number
  type?: EnumACCOUNT_TYPENullableFilter | ACCOUNT_TYPE | null
  person?: PersonRelationFilter | PersonWhereInput
  project?: ProjectRelationFilter | ProjectWhereInput
}

export type AccountOrderByInput = {
  id?: SortOrder
  username?: SortOrder
  hashedPassword?: SortOrder
  personId?: SortOrder
  projectId?: SortOrder
  type?: SortOrder
}

export type AccountWhereUniqueInput = {
  id?: number
}

export type ChunkWhereInput = {
  AND?: ChunkWhereInput | Enumerable<ChunkWhereInput>
  OR?: ChunkWhereInput | Enumerable<ChunkWhereInput>
  NOT?: ChunkWhereInput | Enumerable<ChunkWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  messageId?: IntFilter | number
  discoveryId?: IntFilter | number
  discovery?: DiscoveryRelationFilter | DiscoveryWhereInput
  message?: MessageRelationFilter | MessageWhereInput
  project?: ProjectRelationFilter | ProjectWhereInput
  textSelections?: TextSelectionListRelationFilter
}

export type ChunkOrderByInput = {
  projectId?: SortOrder
  id?: SortOrder
  messageId?: SortOrder
  discoveryId?: SortOrder
}

export type ChunkWhereUniqueInput = {
  id?: number
}

export type ContributorAttributeWhereInput = {
  AND?: ContributorAttributeWhereInput | Enumerable<ContributorAttributeWhereInput>
  OR?: ContributorAttributeWhereInput | Enumerable<ContributorAttributeWhereInput>
  NOT?: ContributorAttributeWhereInput | Enumerable<ContributorAttributeWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  appliesTo?: EnumENTITY_TYPENullableFilter | ENTITY_TYPE | null
  name?: StringFilter | string
  type?: EnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter | CONTRIBUTOR_ATTRIBUTE_TYPE
  project?: ProjectRelationFilter | ProjectWhereInput
  contributorAttributeValues?: ContributorAttributeValueListRelationFilter
}

export type ContributorAttributeOrderByInput = {
  projectId?: SortOrder
  id?: SortOrder
  appliesTo?: SortOrder
  name?: SortOrder
  type?: SortOrder
}

export type ContributorAttributeWhereUniqueInput = {
  id_type?: IdTypeCompoundUniqueInput
}

export type ContributorAttributeValueWhereInput = {
  AND?: ContributorAttributeValueWhereInput | Enumerable<ContributorAttributeValueWhereInput>
  OR?: ContributorAttributeValueWhereInput | Enumerable<ContributorAttributeValueWhereInput>
  NOT?: ContributorAttributeValueWhereInput | Enumerable<ContributorAttributeValueWhereInput>
  id?: IntFilter | number
  contributorAttributeId?: IntFilter | number
  contributorAttributeType?: EnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter | CONTRIBUTOR_ATTRIBUTE_TYPE
  personId?: IntFilter | number
  organizationId?: IntFilter | number
  valuetext?: StringNullableFilter | string | null
  contributorAttribute?: ContributorAttributeRelationFilter | ContributorAttributeWhereInput
  organization?: OrganizationRelationFilter | OrganizationWhereInput
  person?: PersonRelationFilter | PersonWhereInput
}

export type ContributorAttributeValueOrderByInput = {
  id?: SortOrder
  contributorAttributeId?: SortOrder
  contributorAttributeType?: SortOrder
  personId?: SortOrder
  organizationId?: SortOrder
  valuetext?: SortOrder
}

export type ContributorAttributeValueWhereUniqueInput = {
  id?: number
  ContributorAttributeValue_contributorAttributeId_personId_o_key?: ContributorAttributeValue_contributorAttributeId_personId_o_keyCompoundUniqueInput
}

export type DiscoveryWhereInput = {
  AND?: DiscoveryWhereInput | Enumerable<DiscoveryWhereInput>
  OR?: DiscoveryWhereInput | Enumerable<DiscoveryWhereInput>
  NOT?: DiscoveryWhereInput | Enumerable<DiscoveryWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  title?: StringFilter | string
  description?: StringNullableFilter | string | null
  project?: ProjectRelationFilter | ProjectWhereInput
  chunks?: ChunkListRelationFilter
}

export type DiscoveryOrderByInput = {
  projectId?: SortOrder
  id?: SortOrder
  title?: SortOrder
  description?: SortOrder
}

export type DiscoveryWhereUniqueInput = {
  id?: number
}

export type MessageWhereInput = {
  AND?: MessageWhereInput | Enumerable<MessageWhereInput>
  OR?: MessageWhereInput | Enumerable<MessageWhereInput>
  NOT?: MessageWhereInput | Enumerable<MessageWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  requesterId?: IntFilter | number
  submitterId?: IntFilter | number
  clientId?: StringNullableFilter | string | null
  title?: StringNullableFilter | string | null
  content?: StringNullableFilter | string | null
  project?: ProjectRelationFilter | ProjectWhereInput
  person_Message_requesterIdToPerson?: PersonRelationFilter | PersonWhereInput
  person_Message_submitterIdToPerson?: PersonRelationFilter | PersonWhereInput
  chunks?: ChunkListRelationFilter
  subMessages?: SubMessageListRelationFilter
}

export type MessageOrderByInput = {
  projectId?: SortOrder
  id?: SortOrder
  requesterId?: SortOrder
  submitterId?: SortOrder
  clientId?: SortOrder
  title?: SortOrder
  content?: SortOrder
}

export type MessageWhereUniqueInput = {
  id?: number
}

export type OrganizationWhereInput = {
  AND?: OrganizationWhereInput | Enumerable<OrganizationWhereInput>
  OR?: OrganizationWhereInput | Enumerable<OrganizationWhereInput>
  NOT?: OrganizationWhereInput | Enumerable<OrganizationWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  name?: StringFilter | string
  project?: ProjectRelationFilter | ProjectWhereInput
  contributorAttributeValues?: ContributorAttributeValueListRelationFilter
  persons?: PersonListRelationFilter
}

export type OrganizationOrderByInput = {
  projectId?: SortOrder
  id?: SortOrder
  name?: SortOrder
}

export type OrganizationWhereUniqueInput = {
  id?: number
}

export type PersonWhereInput = {
  AND?: PersonWhereInput | Enumerable<PersonWhereInput>
  OR?: PersonWhereInput | Enumerable<PersonWhereInput>
  NOT?: PersonWhereInput | Enumerable<PersonWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  name?: StringFilter | string
  email?: StringFilter | string
  organizationId?: IntFilter | number
  organization?: OrganizationRelationFilter | OrganizationWhereInput
  project?: ProjectRelationFilter | ProjectWhereInput
  accounts?: AccountListRelationFilter
  contributorAttributeValues?: ContributorAttributeValueListRelationFilter
  message_Message_requesterIdToPersons?: MessageListRelationFilter
  message_Message_submitterIdToPersons?: MessageListRelationFilter
  subMessages?: SubMessageListRelationFilter
}

export type PersonOrderByInput = {
  projectId?: SortOrder
  id?: SortOrder
  name?: SortOrder
  email?: SortOrder
  organizationId?: SortOrder
}

export type PersonWhereUniqueInput = {
  id?: number
}

export type ProjectWhereInput = {
  AND?: ProjectWhereInput | Enumerable<ProjectWhereInput>
  OR?: ProjectWhereInput | Enumerable<ProjectWhereInput>
  NOT?: ProjectWhereInput | Enumerable<ProjectWhereInput>
  id?: IntFilter | number
  name?: StringFilter | string
  accounts?: AccountListRelationFilter
  chunks?: ChunkListRelationFilter
  contributorAttributes?: ContributorAttributeListRelationFilter
  discoverys?: DiscoveryListRelationFilter
  messages?: MessageListRelationFilter
  organizations?: OrganizationListRelationFilter
  persons?: PersonListRelationFilter
}

export type ProjectOrderByInput = {
  id?: SortOrder
  name?: SortOrder
}

export type ProjectWhereUniqueInput = {
  id?: number
}

export type SubMessageWhereInput = {
  AND?: SubMessageWhereInput | Enumerable<SubMessageWhereInput>
  OR?: SubMessageWhereInput | Enumerable<SubMessageWhereInput>
  NOT?: SubMessageWhereInput | Enumerable<SubMessageWhereInput>
  id?: IntFilter | number
  submitterId?: IntFilter | number
  content?: StringFilter | string
  messageId?: IntFilter | number
  message?: MessageRelationFilter | MessageWhereInput
  person?: PersonRelationFilter | PersonWhereInput
}

export type SubMessageOrderByInput = {
  id?: SortOrder
  submitterId?: SortOrder
  content?: SortOrder
  messageId?: SortOrder
}

export type SubMessageWhereUniqueInput = {
  id?: number
}

export type TextSelectionWhereInput = {
  AND?: TextSelectionWhereInput | Enumerable<TextSelectionWhereInput>
  OR?: TextSelectionWhereInput | Enumerable<TextSelectionWhereInput>
  NOT?: TextSelectionWhereInput | Enumerable<TextSelectionWhereInput>
  id?: IntFilter | number
  offsetstart?: FloatFilter | number
  length?: FloatFilter | number
  submessagenumber?: IntFilter | number
  content?: StringFilter | string
  chunkId?: IntFilter | number
  chunk?: ChunkRelationFilter | ChunkWhereInput
}

export type TextSelectionOrderByInput = {
  id?: SortOrder
  offsetstart?: SortOrder
  length?: SortOrder
  submessagenumber?: SortOrder
  content?: SortOrder
  chunkId?: SortOrder
}

export type TextSelectionWhereUniqueInput = {
  id?: number
}

export type AccountCreateInput = {
  username: string
  hashedPassword: string
  type?: ACCOUNT_TYPE | null
  person: PersonCreateOneWithoutAccountsInput
  project: ProjectCreateOneWithoutAccountsInput
}

export type AccountUpdateInput = {
  username?: string | StringFieldUpdateOperationsInput
  hashedPassword?: string | StringFieldUpdateOperationsInput
  type?: ACCOUNT_TYPE | NullableEnumACCOUNT_TYPEFieldUpdateOperationsInput | null
  person?: PersonUpdateOneRequiredWithoutAccountsInput
  project?: ProjectUpdateOneRequiredWithoutAccountsInput
}

export type AccountUpdateManyMutationInput = {
  username?: string | StringFieldUpdateOperationsInput
  hashedPassword?: string | StringFieldUpdateOperationsInput
  type?: ACCOUNT_TYPE | NullableEnumACCOUNT_TYPEFieldUpdateOperationsInput | null
}

export type ChunkCreateInput = {
  discovery: DiscoveryCreateOneWithoutChunksInput
  message: MessageCreateOneWithoutChunksInput
  project: ProjectCreateOneWithoutChunksInput
  textSelections?: TextSelectionCreateManyWithoutChunkInput
}

export type ChunkUpdateInput = {
  discovery?: DiscoveryUpdateOneRequiredWithoutChunksInput
  message?: MessageUpdateOneRequiredWithoutChunksInput
  project?: ProjectUpdateOneRequiredWithoutChunksInput
  textSelections?: TextSelectionUpdateManyWithoutChunkInput
}

export type ChunkUpdateManyMutationInput = {

}

export type ContributorAttributeCreateInput = {
  id?: number
  appliesTo?: ENTITY_TYPE | null
  name: string
  type: CONTRIBUTOR_ATTRIBUTE_TYPE
  project: ProjectCreateOneWithoutContributorAttributesInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutContributorAttributeInput
}

export type ContributorAttributeUpdateInput = {
  id?: number | IntFieldUpdateOperationsInput
  appliesTo?: ENTITY_TYPE | NullableEnumENTITY_TYPEFieldUpdateOperationsInput | null
  name?: string | StringFieldUpdateOperationsInput
  type?: CONTRIBUTOR_ATTRIBUTE_TYPE | EnumCONTRIBUTOR_ATTRIBUTE_TYPEFieldUpdateOperationsInput
  project?: ProjectUpdateOneRequiredWithoutContributorAttributesInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutContributorAttributeInput
}

export type ContributorAttributeUpdateManyMutationInput = {
  id?: number | IntFieldUpdateOperationsInput
  appliesTo?: ENTITY_TYPE | NullableEnumENTITY_TYPEFieldUpdateOperationsInput | null
  name?: string | StringFieldUpdateOperationsInput
  type?: CONTRIBUTOR_ATTRIBUTE_TYPE | EnumCONTRIBUTOR_ATTRIBUTE_TYPEFieldUpdateOperationsInput
}

export type ContributorAttributeValueCreateInput = {
  valuetext?: string | null
  contributorAttribute: ContributorAttributeCreateOneWithoutContributorAttributeValuesInput
  organization: OrganizationCreateOneWithoutContributorAttributeValuesInput
  person: PersonCreateOneWithoutContributorAttributeValuesInput
}

export type ContributorAttributeValueUpdateInput = {
  valuetext?: string | NullableStringFieldUpdateOperationsInput | null
  contributorAttribute?: ContributorAttributeUpdateOneRequiredWithoutContributorAttributeValuesInput
  organization?: OrganizationUpdateOneRequiredWithoutContributorAttributeValuesInput
  person?: PersonUpdateOneRequiredWithoutContributorAttributeValuesInput
}

export type ContributorAttributeValueUpdateManyMutationInput = {
  valuetext?: string | NullableStringFieldUpdateOperationsInput | null
}

export type DiscoveryCreateInput = {
  title: string
  description?: string | null
  project: ProjectCreateOneWithoutDiscoverysInput
  chunks?: ChunkCreateManyWithoutDiscoveryInput
}

export type DiscoveryUpdateInput = {
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutDiscoverysInput
  chunks?: ChunkUpdateManyWithoutDiscoveryInput
}

export type DiscoveryUpdateManyMutationInput = {
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
}

export type MessageCreateInput = {
  clientId?: string | null
  title?: string | null
  content?: string | null
  project: ProjectCreateOneWithoutMessagesInput
  person_Message_requesterIdToPerson: PersonCreateOneWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson: PersonCreateOneWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkCreateManyWithoutMessageInput
  subMessages?: SubMessageCreateManyWithoutMessageInput
}

export type MessageUpdateInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutMessagesInput
  person_Message_requesterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkUpdateManyWithoutMessageInput
  subMessages?: SubMessageUpdateManyWithoutMessageInput
}

export type MessageUpdateManyMutationInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
}

export type OrganizationCreateInput = {
  name: string
  project: ProjectCreateOneWithoutOrganizationsInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutOrganizationInput
  persons?: PersonCreateManyWithoutOrganizationInput
}

export type OrganizationUpdateInput = {
  name?: string | StringFieldUpdateOperationsInput
  project?: ProjectUpdateOneRequiredWithoutOrganizationsInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutOrganizationInput
  persons?: PersonUpdateManyWithoutOrganizationInput
}

export type OrganizationUpdateManyMutationInput = {
  name?: string | StringFieldUpdateOperationsInput
}

export type PersonCreateInput = {
  name: string
  email: string
  organization: OrganizationCreateOneWithoutPersonsInput
  project: ProjectCreateOneWithoutPersonsInput
  accounts?: AccountCreateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageCreateManyWithoutPersonInput
}

export type PersonUpdateInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  organization?: OrganizationUpdateOneRequiredWithoutPersonsInput
  project?: ProjectUpdateOneRequiredWithoutPersonsInput
  accounts?: AccountUpdateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageUpdateManyWithoutPersonInput
}

export type PersonUpdateManyMutationInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
}

export type ProjectCreateInput = {
  name: string
  accounts?: AccountCreateManyWithoutProjectInput
  chunks?: ChunkCreateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeCreateManyWithoutProjectInput
  discoverys?: DiscoveryCreateManyWithoutProjectInput
  messages?: MessageCreateManyWithoutProjectInput
  organizations?: OrganizationCreateManyWithoutProjectInput
  persons?: PersonCreateManyWithoutProjectInput
}

export type ProjectUpdateInput = {
  name?: string | StringFieldUpdateOperationsInput
  accounts?: AccountUpdateManyWithoutProjectInput
  chunks?: ChunkUpdateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeUpdateManyWithoutProjectInput
  discoverys?: DiscoveryUpdateManyWithoutProjectInput
  messages?: MessageUpdateManyWithoutProjectInput
  organizations?: OrganizationUpdateManyWithoutProjectInput
  persons?: PersonUpdateManyWithoutProjectInput
}

export type ProjectUpdateManyMutationInput = {
  name?: string | StringFieldUpdateOperationsInput
}

export type SubMessageCreateInput = {
  content: string
  message: MessageCreateOneWithoutSubMessagesInput
  person: PersonCreateOneWithoutSubMessagesInput
}

export type SubMessageUpdateInput = {
  content?: string | StringFieldUpdateOperationsInput
  message?: MessageUpdateOneRequiredWithoutSubMessagesInput
  person?: PersonUpdateOneRequiredWithoutSubMessagesInput
}

export type SubMessageUpdateManyMutationInput = {
  content?: string | StringFieldUpdateOperationsInput
}

export type TextSelectionCreateInput = {
  offsetstart: number
  length: number
  submessagenumber: number
  content: string
  chunk: ChunkCreateOneWithoutTextSelectionsInput
}

export type TextSelectionUpdateInput = {
  offsetstart?: number | FloatFieldUpdateOperationsInput
  length?: number | FloatFieldUpdateOperationsInput
  submessagenumber?: number | IntFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
  chunk?: ChunkUpdateOneRequiredWithoutTextSelectionsInput
}

export type TextSelectionUpdateManyMutationInput = {
  offsetstart?: number | FloatFieldUpdateOperationsInput
  length?: number | FloatFieldUpdateOperationsInput
  submessagenumber?: number | IntFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type StringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  mode?: QueryMode
  not?: string | NestedStringFilter
}

export type EnumACCOUNT_TYPENullableFilter = {
  equals?: ACCOUNT_TYPE | null
  in?: Enumerable<ACCOUNT_TYPE> | null
  notIn?: Enumerable<ACCOUNT_TYPE> | null
  not?: ACCOUNT_TYPE | NestedEnumACCOUNT_TYPENullableFilter | null
}

export type PersonRelationFilter = {
  is?: PersonWhereInput
  isNot?: PersonWhereInput
}

export type ProjectRelationFilter = {
  is?: ProjectWhereInput
  isNot?: ProjectWhereInput
}

export type DiscoveryRelationFilter = {
  is?: DiscoveryWhereInput
  isNot?: DiscoveryWhereInput
}

export type MessageRelationFilter = {
  is?: MessageWhereInput
  isNot?: MessageWhereInput
}

export type TextSelectionListRelationFilter = {
  every?: TextSelectionWhereInput
  some?: TextSelectionWhereInput
  none?: TextSelectionWhereInput
}

export type EnumENTITY_TYPENullableFilter = {
  equals?: ENTITY_TYPE | null
  in?: Enumerable<ENTITY_TYPE> | null
  notIn?: Enumerable<ENTITY_TYPE> | null
  not?: ENTITY_TYPE | NestedEnumENTITY_TYPENullableFilter | null
}

export type EnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter = {
  equals?: CONTRIBUTOR_ATTRIBUTE_TYPE
  in?: Enumerable<CONTRIBUTOR_ATTRIBUTE_TYPE>
  notIn?: Enumerable<CONTRIBUTOR_ATTRIBUTE_TYPE>
  not?: CONTRIBUTOR_ATTRIBUTE_TYPE | NestedEnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter
}

export type ContributorAttributeValueListRelationFilter = {
  every?: ContributorAttributeValueWhereInput
  some?: ContributorAttributeValueWhereInput
  none?: ContributorAttributeValueWhereInput
}

export type IdTypeCompoundUniqueInput = {
  id: number
  type: CONTRIBUTOR_ATTRIBUTE_TYPE
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  mode?: QueryMode
  not?: string | NestedStringNullableFilter | null
}

export type ContributorAttributeRelationFilter = {
  is?: ContributorAttributeWhereInput
  isNot?: ContributorAttributeWhereInput
}

export type OrganizationRelationFilter = {
  is?: OrganizationWhereInput
  isNot?: OrganizationWhereInput
}

export type ContributorAttributeValue_contributorAttributeId_personId_o_keyCompoundUniqueInput = {
  contributorAttributeId: number
  personId: number
  organizationId: number
}

export type ChunkListRelationFilter = {
  every?: ChunkWhereInput
  some?: ChunkWhereInput
  none?: ChunkWhereInput
}

export type SubMessageListRelationFilter = {
  every?: SubMessageWhereInput
  some?: SubMessageWhereInput
  none?: SubMessageWhereInput
}

export type PersonListRelationFilter = {
  every?: PersonWhereInput
  some?: PersonWhereInput
  none?: PersonWhereInput
}

export type AccountListRelationFilter = {
  every?: AccountWhereInput
  some?: AccountWhereInput
  none?: AccountWhereInput
}

export type MessageListRelationFilter = {
  every?: MessageWhereInput
  some?: MessageWhereInput
  none?: MessageWhereInput
}

export type ContributorAttributeListRelationFilter = {
  every?: ContributorAttributeWhereInput
  some?: ContributorAttributeWhereInput
  none?: ContributorAttributeWhereInput
}

export type DiscoveryListRelationFilter = {
  every?: DiscoveryWhereInput
  some?: DiscoveryWhereInput
  none?: DiscoveryWhereInput
}

export type OrganizationListRelationFilter = {
  every?: OrganizationWhereInput
  some?: OrganizationWhereInput
  none?: OrganizationWhereInput
}

export type FloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type ChunkRelationFilter = {
  is?: ChunkWhereInput
  isNot?: ChunkWhereInput
}

export type PersonCreateOneWithoutAccountsInput = {
  create?: PersonCreateWithoutAccountsInput
  connect?: PersonWhereUniqueInput
}

export type ProjectCreateOneWithoutAccountsInput = {
  create?: ProjectCreateWithoutAccountsInput
  connect?: ProjectWhereUniqueInput
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type NullableEnumACCOUNT_TYPEFieldUpdateOperationsInput = {
  set?: ACCOUNT_TYPE | null
}

export type PersonUpdateOneRequiredWithoutAccountsInput = {
  create?: PersonCreateWithoutAccountsInput
  connect?: PersonWhereUniqueInput
  update?: PersonUpdateWithoutAccountsDataInput
  upsert?: PersonUpsertWithoutAccountsInput
}

export type ProjectUpdateOneRequiredWithoutAccountsInput = {
  create?: ProjectCreateWithoutAccountsInput
  connect?: ProjectWhereUniqueInput
  update?: ProjectUpdateWithoutAccountsDataInput
  upsert?: ProjectUpsertWithoutAccountsInput
}

export type DiscoveryCreateOneWithoutChunksInput = {
  create?: DiscoveryCreateWithoutChunksInput
  connect?: DiscoveryWhereUniqueInput
}

export type MessageCreateOneWithoutChunksInput = {
  create?: MessageCreateWithoutChunksInput
  connect?: MessageWhereUniqueInput
}

export type ProjectCreateOneWithoutChunksInput = {
  create?: ProjectCreateWithoutChunksInput
  connect?: ProjectWhereUniqueInput
}

export type TextSelectionCreateManyWithoutChunkInput = {
  create?: TextSelectionCreateWithoutChunkInput | Enumerable<TextSelectionCreateWithoutChunkInput>
  connect?: TextSelectionWhereUniqueInput | Enumerable<TextSelectionWhereUniqueInput>
}

export type DiscoveryUpdateOneRequiredWithoutChunksInput = {
  create?: DiscoveryCreateWithoutChunksInput
  connect?: DiscoveryWhereUniqueInput
  update?: DiscoveryUpdateWithoutChunksDataInput
  upsert?: DiscoveryUpsertWithoutChunksInput
}

export type MessageUpdateOneRequiredWithoutChunksInput = {
  create?: MessageCreateWithoutChunksInput
  connect?: MessageWhereUniqueInput
  update?: MessageUpdateWithoutChunksDataInput
  upsert?: MessageUpsertWithoutChunksInput
}

export type ProjectUpdateOneRequiredWithoutChunksInput = {
  create?: ProjectCreateWithoutChunksInput
  connect?: ProjectWhereUniqueInput
  update?: ProjectUpdateWithoutChunksDataInput
  upsert?: ProjectUpsertWithoutChunksInput
}

export type TextSelectionUpdateManyWithoutChunkInput = {
  create?: TextSelectionCreateWithoutChunkInput | Enumerable<TextSelectionCreateWithoutChunkInput>
  connect?: TextSelectionWhereUniqueInput | Enumerable<TextSelectionWhereUniqueInput>
  set?: TextSelectionWhereUniqueInput | Enumerable<TextSelectionWhereUniqueInput>
  disconnect?: TextSelectionWhereUniqueInput | Enumerable<TextSelectionWhereUniqueInput>
  delete?: TextSelectionWhereUniqueInput | Enumerable<TextSelectionWhereUniqueInput>
  update?: TextSelectionUpdateWithWhereUniqueWithoutChunkInput | Enumerable<TextSelectionUpdateWithWhereUniqueWithoutChunkInput>
  updateMany?: TextSelectionUpdateManyWithWhereNestedInput | Enumerable<TextSelectionUpdateManyWithWhereNestedInput>
  deleteMany?: TextSelectionScalarWhereInput | Enumerable<TextSelectionScalarWhereInput>
  upsert?: TextSelectionUpsertWithWhereUniqueWithoutChunkInput | Enumerable<TextSelectionUpsertWithWhereUniqueWithoutChunkInput>
}

export type ProjectCreateOneWithoutContributorAttributesInput = {
  create?: ProjectCreateWithoutContributorAttributesInput
  connect?: ProjectWhereUniqueInput
}

export type ContributorAttributeValueCreateManyWithoutContributorAttributeInput = {
  create?: ContributorAttributeValueCreateWithoutContributorAttributeInput | Enumerable<ContributorAttributeValueCreateWithoutContributorAttributeInput>
  connect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableEnumENTITY_TYPEFieldUpdateOperationsInput = {
  set?: ENTITY_TYPE | null
}

export type EnumCONTRIBUTOR_ATTRIBUTE_TYPEFieldUpdateOperationsInput = {
  set?: CONTRIBUTOR_ATTRIBUTE_TYPE
}

export type ProjectUpdateOneRequiredWithoutContributorAttributesInput = {
  create?: ProjectCreateWithoutContributorAttributesInput
  connect?: ProjectWhereUniqueInput
  update?: ProjectUpdateWithoutContributorAttributesDataInput
  upsert?: ProjectUpsertWithoutContributorAttributesInput
}

export type ContributorAttributeValueUpdateManyWithoutContributorAttributeInput = {
  create?: ContributorAttributeValueCreateWithoutContributorAttributeInput | Enumerable<ContributorAttributeValueCreateWithoutContributorAttributeInput>
  connect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  set?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  disconnect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  delete?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  update?: ContributorAttributeValueUpdateWithWhereUniqueWithoutContributorAttributeInput | Enumerable<ContributorAttributeValueUpdateWithWhereUniqueWithoutContributorAttributeInput>
  updateMany?: ContributorAttributeValueUpdateManyWithWhereNestedInput | Enumerable<ContributorAttributeValueUpdateManyWithWhereNestedInput>
  deleteMany?: ContributorAttributeValueScalarWhereInput | Enumerable<ContributorAttributeValueScalarWhereInput>
  upsert?: ContributorAttributeValueUpsertWithWhereUniqueWithoutContributorAttributeInput | Enumerable<ContributorAttributeValueUpsertWithWhereUniqueWithoutContributorAttributeInput>
}

export type ContributorAttributeCreateOneWithoutContributorAttributeValuesInput = {
  create?: ContributorAttributeCreateWithoutContributorAttributeValuesInput
  connect?: ContributorAttributeWhereUniqueInput
}

export type OrganizationCreateOneWithoutContributorAttributeValuesInput = {
  create?: OrganizationCreateWithoutContributorAttributeValuesInput
  connect?: OrganizationWhereUniqueInput
}

export type PersonCreateOneWithoutContributorAttributeValuesInput = {
  create?: PersonCreateWithoutContributorAttributeValuesInput
  connect?: PersonWhereUniqueInput
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type ContributorAttributeUpdateOneRequiredWithoutContributorAttributeValuesInput = {
  create?: ContributorAttributeCreateWithoutContributorAttributeValuesInput
  connect?: ContributorAttributeWhereUniqueInput
  update?: ContributorAttributeUpdateWithoutContributorAttributeValuesDataInput
  upsert?: ContributorAttributeUpsertWithoutContributorAttributeValuesInput
}

export type OrganizationUpdateOneRequiredWithoutContributorAttributeValuesInput = {
  create?: OrganizationCreateWithoutContributorAttributeValuesInput
  connect?: OrganizationWhereUniqueInput
  update?: OrganizationUpdateWithoutContributorAttributeValuesDataInput
  upsert?: OrganizationUpsertWithoutContributorAttributeValuesInput
}

export type PersonUpdateOneRequiredWithoutContributorAttributeValuesInput = {
  create?: PersonCreateWithoutContributorAttributeValuesInput
  connect?: PersonWhereUniqueInput
  update?: PersonUpdateWithoutContributorAttributeValuesDataInput
  upsert?: PersonUpsertWithoutContributorAttributeValuesInput
}

export type ProjectCreateOneWithoutDiscoverysInput = {
  create?: ProjectCreateWithoutDiscoverysInput
  connect?: ProjectWhereUniqueInput
}

export type ChunkCreateManyWithoutDiscoveryInput = {
  create?: ChunkCreateWithoutDiscoveryInput | Enumerable<ChunkCreateWithoutDiscoveryInput>
  connect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
}

export type ProjectUpdateOneRequiredWithoutDiscoverysInput = {
  create?: ProjectCreateWithoutDiscoverysInput
  connect?: ProjectWhereUniqueInput
  update?: ProjectUpdateWithoutDiscoverysDataInput
  upsert?: ProjectUpsertWithoutDiscoverysInput
}

export type ChunkUpdateManyWithoutDiscoveryInput = {
  create?: ChunkCreateWithoutDiscoveryInput | Enumerable<ChunkCreateWithoutDiscoveryInput>
  connect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  set?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  disconnect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  delete?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  update?: ChunkUpdateWithWhereUniqueWithoutDiscoveryInput | Enumerable<ChunkUpdateWithWhereUniqueWithoutDiscoveryInput>
  updateMany?: ChunkUpdateManyWithWhereNestedInput | Enumerable<ChunkUpdateManyWithWhereNestedInput>
  deleteMany?: ChunkScalarWhereInput | Enumerable<ChunkScalarWhereInput>
  upsert?: ChunkUpsertWithWhereUniqueWithoutDiscoveryInput | Enumerable<ChunkUpsertWithWhereUniqueWithoutDiscoveryInput>
}

export type ProjectCreateOneWithoutMessagesInput = {
  create?: ProjectCreateWithoutMessagesInput
  connect?: ProjectWhereUniqueInput
}

export type PersonCreateOneWithoutMessage_Message_requesterIdToPersonsInput = {
  create?: PersonCreateWithoutMessage_Message_requesterIdToPersonsInput
  connect?: PersonWhereUniqueInput
}

export type PersonCreateOneWithoutMessage_Message_submitterIdToPersonsInput = {
  create?: PersonCreateWithoutMessage_Message_submitterIdToPersonsInput
  connect?: PersonWhereUniqueInput
}

export type ChunkCreateManyWithoutMessageInput = {
  create?: ChunkCreateWithoutMessageInput | Enumerable<ChunkCreateWithoutMessageInput>
  connect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
}

export type SubMessageCreateManyWithoutMessageInput = {
  create?: SubMessageCreateWithoutMessageInput | Enumerable<SubMessageCreateWithoutMessageInput>
  connect?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
}

export type ProjectUpdateOneRequiredWithoutMessagesInput = {
  create?: ProjectCreateWithoutMessagesInput
  connect?: ProjectWhereUniqueInput
  update?: ProjectUpdateWithoutMessagesDataInput
  upsert?: ProjectUpsertWithoutMessagesInput
}

export type PersonUpdateOneRequiredWithoutMessage_Message_requesterIdToPersonsInput = {
  create?: PersonCreateWithoutMessage_Message_requesterIdToPersonsInput
  connect?: PersonWhereUniqueInput
  update?: PersonUpdateWithoutMessage_Message_requesterIdToPersonsDataInput
  upsert?: PersonUpsertWithoutMessage_Message_requesterIdToPersonsInput
}

export type PersonUpdateOneRequiredWithoutMessage_Message_submitterIdToPersonsInput = {
  create?: PersonCreateWithoutMessage_Message_submitterIdToPersonsInput
  connect?: PersonWhereUniqueInput
  update?: PersonUpdateWithoutMessage_Message_submitterIdToPersonsDataInput
  upsert?: PersonUpsertWithoutMessage_Message_submitterIdToPersonsInput
}

export type ChunkUpdateManyWithoutMessageInput = {
  create?: ChunkCreateWithoutMessageInput | Enumerable<ChunkCreateWithoutMessageInput>
  connect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  set?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  disconnect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  delete?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  update?: ChunkUpdateWithWhereUniqueWithoutMessageInput | Enumerable<ChunkUpdateWithWhereUniqueWithoutMessageInput>
  updateMany?: ChunkUpdateManyWithWhereNestedInput | Enumerable<ChunkUpdateManyWithWhereNestedInput>
  deleteMany?: ChunkScalarWhereInput | Enumerable<ChunkScalarWhereInput>
  upsert?: ChunkUpsertWithWhereUniqueWithoutMessageInput | Enumerable<ChunkUpsertWithWhereUniqueWithoutMessageInput>
}

export type SubMessageUpdateManyWithoutMessageInput = {
  create?: SubMessageCreateWithoutMessageInput | Enumerable<SubMessageCreateWithoutMessageInput>
  connect?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  set?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  disconnect?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  delete?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  update?: SubMessageUpdateWithWhereUniqueWithoutMessageInput | Enumerable<SubMessageUpdateWithWhereUniqueWithoutMessageInput>
  updateMany?: SubMessageUpdateManyWithWhereNestedInput | Enumerable<SubMessageUpdateManyWithWhereNestedInput>
  deleteMany?: SubMessageScalarWhereInput | Enumerable<SubMessageScalarWhereInput>
  upsert?: SubMessageUpsertWithWhereUniqueWithoutMessageInput | Enumerable<SubMessageUpsertWithWhereUniqueWithoutMessageInput>
}

export type ProjectCreateOneWithoutOrganizationsInput = {
  create?: ProjectCreateWithoutOrganizationsInput
  connect?: ProjectWhereUniqueInput
}

export type ContributorAttributeValueCreateManyWithoutOrganizationInput = {
  create?: ContributorAttributeValueCreateWithoutOrganizationInput | Enumerable<ContributorAttributeValueCreateWithoutOrganizationInput>
  connect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
}

export type PersonCreateManyWithoutOrganizationInput = {
  create?: PersonCreateWithoutOrganizationInput | Enumerable<PersonCreateWithoutOrganizationInput>
  connect?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
}

export type ProjectUpdateOneRequiredWithoutOrganizationsInput = {
  create?: ProjectCreateWithoutOrganizationsInput
  connect?: ProjectWhereUniqueInput
  update?: ProjectUpdateWithoutOrganizationsDataInput
  upsert?: ProjectUpsertWithoutOrganizationsInput
}

export type ContributorAttributeValueUpdateManyWithoutOrganizationInput = {
  create?: ContributorAttributeValueCreateWithoutOrganizationInput | Enumerable<ContributorAttributeValueCreateWithoutOrganizationInput>
  connect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  set?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  disconnect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  delete?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  update?: ContributorAttributeValueUpdateWithWhereUniqueWithoutOrganizationInput | Enumerable<ContributorAttributeValueUpdateWithWhereUniqueWithoutOrganizationInput>
  updateMany?: ContributorAttributeValueUpdateManyWithWhereNestedInput | Enumerable<ContributorAttributeValueUpdateManyWithWhereNestedInput>
  deleteMany?: ContributorAttributeValueScalarWhereInput | Enumerable<ContributorAttributeValueScalarWhereInput>
  upsert?: ContributorAttributeValueUpsertWithWhereUniqueWithoutOrganizationInput | Enumerable<ContributorAttributeValueUpsertWithWhereUniqueWithoutOrganizationInput>
}

export type PersonUpdateManyWithoutOrganizationInput = {
  create?: PersonCreateWithoutOrganizationInput | Enumerable<PersonCreateWithoutOrganizationInput>
  connect?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  set?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  disconnect?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  delete?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  update?: PersonUpdateWithWhereUniqueWithoutOrganizationInput | Enumerable<PersonUpdateWithWhereUniqueWithoutOrganizationInput>
  updateMany?: PersonUpdateManyWithWhereNestedInput | Enumerable<PersonUpdateManyWithWhereNestedInput>
  deleteMany?: PersonScalarWhereInput | Enumerable<PersonScalarWhereInput>
  upsert?: PersonUpsertWithWhereUniqueWithoutOrganizationInput | Enumerable<PersonUpsertWithWhereUniqueWithoutOrganizationInput>
}

export type OrganizationCreateOneWithoutPersonsInput = {
  create?: OrganizationCreateWithoutPersonsInput
  connect?: OrganizationWhereUniqueInput
}

export type ProjectCreateOneWithoutPersonsInput = {
  create?: ProjectCreateWithoutPersonsInput
  connect?: ProjectWhereUniqueInput
}

export type AccountCreateManyWithoutPersonInput = {
  create?: AccountCreateWithoutPersonInput | Enumerable<AccountCreateWithoutPersonInput>
  connect?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
}

export type ContributorAttributeValueCreateManyWithoutPersonInput = {
  create?: ContributorAttributeValueCreateWithoutPersonInput | Enumerable<ContributorAttributeValueCreateWithoutPersonInput>
  connect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
}

export type MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput = {
  create?: MessageCreateWithoutPerson_Message_requesterIdToPersonInput | Enumerable<MessageCreateWithoutPerson_Message_requesterIdToPersonInput>
  connect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
}

export type MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput = {
  create?: MessageCreateWithoutPerson_Message_submitterIdToPersonInput | Enumerable<MessageCreateWithoutPerson_Message_submitterIdToPersonInput>
  connect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
}

export type SubMessageCreateManyWithoutPersonInput = {
  create?: SubMessageCreateWithoutPersonInput | Enumerable<SubMessageCreateWithoutPersonInput>
  connect?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
}

export type OrganizationUpdateOneRequiredWithoutPersonsInput = {
  create?: OrganizationCreateWithoutPersonsInput
  connect?: OrganizationWhereUniqueInput
  update?: OrganizationUpdateWithoutPersonsDataInput
  upsert?: OrganizationUpsertWithoutPersonsInput
}

export type ProjectUpdateOneRequiredWithoutPersonsInput = {
  create?: ProjectCreateWithoutPersonsInput
  connect?: ProjectWhereUniqueInput
  update?: ProjectUpdateWithoutPersonsDataInput
  upsert?: ProjectUpsertWithoutPersonsInput
}

export type AccountUpdateManyWithoutPersonInput = {
  create?: AccountCreateWithoutPersonInput | Enumerable<AccountCreateWithoutPersonInput>
  connect?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  set?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  disconnect?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  delete?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  update?: AccountUpdateWithWhereUniqueWithoutPersonInput | Enumerable<AccountUpdateWithWhereUniqueWithoutPersonInput>
  updateMany?: AccountUpdateManyWithWhereNestedInput | Enumerable<AccountUpdateManyWithWhereNestedInput>
  deleteMany?: AccountScalarWhereInput | Enumerable<AccountScalarWhereInput>
  upsert?: AccountUpsertWithWhereUniqueWithoutPersonInput | Enumerable<AccountUpsertWithWhereUniqueWithoutPersonInput>
}

export type ContributorAttributeValueUpdateManyWithoutPersonInput = {
  create?: ContributorAttributeValueCreateWithoutPersonInput | Enumerable<ContributorAttributeValueCreateWithoutPersonInput>
  connect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  set?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  disconnect?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  delete?: ContributorAttributeValueWhereUniqueInput | Enumerable<ContributorAttributeValueWhereUniqueInput>
  update?: ContributorAttributeValueUpdateWithWhereUniqueWithoutPersonInput | Enumerable<ContributorAttributeValueUpdateWithWhereUniqueWithoutPersonInput>
  updateMany?: ContributorAttributeValueUpdateManyWithWhereNestedInput | Enumerable<ContributorAttributeValueUpdateManyWithWhereNestedInput>
  deleteMany?: ContributorAttributeValueScalarWhereInput | Enumerable<ContributorAttributeValueScalarWhereInput>
  upsert?: ContributorAttributeValueUpsertWithWhereUniqueWithoutPersonInput | Enumerable<ContributorAttributeValueUpsertWithWhereUniqueWithoutPersonInput>
}

export type MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput = {
  create?: MessageCreateWithoutPerson_Message_requesterIdToPersonInput | Enumerable<MessageCreateWithoutPerson_Message_requesterIdToPersonInput>
  connect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  set?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  disconnect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  delete?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  update?: MessageUpdateWithWhereUniqueWithoutPerson_Message_requesterIdToPersonInput | Enumerable<MessageUpdateWithWhereUniqueWithoutPerson_Message_requesterIdToPersonInput>
  updateMany?: MessageUpdateManyWithWhereNestedInput | Enumerable<MessageUpdateManyWithWhereNestedInput>
  deleteMany?: MessageScalarWhereInput | Enumerable<MessageScalarWhereInput>
  upsert?: MessageUpsertWithWhereUniqueWithoutPerson_Message_requesterIdToPersonInput | Enumerable<MessageUpsertWithWhereUniqueWithoutPerson_Message_requesterIdToPersonInput>
}

export type MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput = {
  create?: MessageCreateWithoutPerson_Message_submitterIdToPersonInput | Enumerable<MessageCreateWithoutPerson_Message_submitterIdToPersonInput>
  connect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  set?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  disconnect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  delete?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  update?: MessageUpdateWithWhereUniqueWithoutPerson_Message_submitterIdToPersonInput | Enumerable<MessageUpdateWithWhereUniqueWithoutPerson_Message_submitterIdToPersonInput>
  updateMany?: MessageUpdateManyWithWhereNestedInput | Enumerable<MessageUpdateManyWithWhereNestedInput>
  deleteMany?: MessageScalarWhereInput | Enumerable<MessageScalarWhereInput>
  upsert?: MessageUpsertWithWhereUniqueWithoutPerson_Message_submitterIdToPersonInput | Enumerable<MessageUpsertWithWhereUniqueWithoutPerson_Message_submitterIdToPersonInput>
}

export type SubMessageUpdateManyWithoutPersonInput = {
  create?: SubMessageCreateWithoutPersonInput | Enumerable<SubMessageCreateWithoutPersonInput>
  connect?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  set?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  disconnect?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  delete?: SubMessageWhereUniqueInput | Enumerable<SubMessageWhereUniqueInput>
  update?: SubMessageUpdateWithWhereUniqueWithoutPersonInput | Enumerable<SubMessageUpdateWithWhereUniqueWithoutPersonInput>
  updateMany?: SubMessageUpdateManyWithWhereNestedInput | Enumerable<SubMessageUpdateManyWithWhereNestedInput>
  deleteMany?: SubMessageScalarWhereInput | Enumerable<SubMessageScalarWhereInput>
  upsert?: SubMessageUpsertWithWhereUniqueWithoutPersonInput | Enumerable<SubMessageUpsertWithWhereUniqueWithoutPersonInput>
}

export type AccountCreateManyWithoutProjectInput = {
  create?: AccountCreateWithoutProjectInput | Enumerable<AccountCreateWithoutProjectInput>
  connect?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
}

export type ChunkCreateManyWithoutProjectInput = {
  create?: ChunkCreateWithoutProjectInput | Enumerable<ChunkCreateWithoutProjectInput>
  connect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
}

export type ContributorAttributeCreateManyWithoutProjectInput = {
  create?: ContributorAttributeCreateWithoutProjectInput | Enumerable<ContributorAttributeCreateWithoutProjectInput>
  connect?: ContributorAttributeWhereUniqueInput | Enumerable<ContributorAttributeWhereUniqueInput>
}

export type DiscoveryCreateManyWithoutProjectInput = {
  create?: DiscoveryCreateWithoutProjectInput | Enumerable<DiscoveryCreateWithoutProjectInput>
  connect?: DiscoveryWhereUniqueInput | Enumerable<DiscoveryWhereUniqueInput>
}

export type MessageCreateManyWithoutProjectInput = {
  create?: MessageCreateWithoutProjectInput | Enumerable<MessageCreateWithoutProjectInput>
  connect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
}

export type OrganizationCreateManyWithoutProjectInput = {
  create?: OrganizationCreateWithoutProjectInput | Enumerable<OrganizationCreateWithoutProjectInput>
  connect?: OrganizationWhereUniqueInput | Enumerable<OrganizationWhereUniqueInput>
}

export type PersonCreateManyWithoutProjectInput = {
  create?: PersonCreateWithoutProjectInput | Enumerable<PersonCreateWithoutProjectInput>
  connect?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
}

export type AccountUpdateManyWithoutProjectInput = {
  create?: AccountCreateWithoutProjectInput | Enumerable<AccountCreateWithoutProjectInput>
  connect?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  set?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  disconnect?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  delete?: AccountWhereUniqueInput | Enumerable<AccountWhereUniqueInput>
  update?: AccountUpdateWithWhereUniqueWithoutProjectInput | Enumerable<AccountUpdateWithWhereUniqueWithoutProjectInput>
  updateMany?: AccountUpdateManyWithWhereNestedInput | Enumerable<AccountUpdateManyWithWhereNestedInput>
  deleteMany?: AccountScalarWhereInput | Enumerable<AccountScalarWhereInput>
  upsert?: AccountUpsertWithWhereUniqueWithoutProjectInput | Enumerable<AccountUpsertWithWhereUniqueWithoutProjectInput>
}

export type ChunkUpdateManyWithoutProjectInput = {
  create?: ChunkCreateWithoutProjectInput | Enumerable<ChunkCreateWithoutProjectInput>
  connect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  set?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  disconnect?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  delete?: ChunkWhereUniqueInput | Enumerable<ChunkWhereUniqueInput>
  update?: ChunkUpdateWithWhereUniqueWithoutProjectInput | Enumerable<ChunkUpdateWithWhereUniqueWithoutProjectInput>
  updateMany?: ChunkUpdateManyWithWhereNestedInput | Enumerable<ChunkUpdateManyWithWhereNestedInput>
  deleteMany?: ChunkScalarWhereInput | Enumerable<ChunkScalarWhereInput>
  upsert?: ChunkUpsertWithWhereUniqueWithoutProjectInput | Enumerable<ChunkUpsertWithWhereUniqueWithoutProjectInput>
}

export type ContributorAttributeUpdateManyWithoutProjectInput = {
  create?: ContributorAttributeCreateWithoutProjectInput | Enumerable<ContributorAttributeCreateWithoutProjectInput>
  connect?: ContributorAttributeWhereUniqueInput | Enumerable<ContributorAttributeWhereUniqueInput>
  set?: ContributorAttributeWhereUniqueInput | Enumerable<ContributorAttributeWhereUniqueInput>
  disconnect?: ContributorAttributeWhereUniqueInput | Enumerable<ContributorAttributeWhereUniqueInput>
  delete?: ContributorAttributeWhereUniqueInput | Enumerable<ContributorAttributeWhereUniqueInput>
  update?: ContributorAttributeUpdateWithWhereUniqueWithoutProjectInput | Enumerable<ContributorAttributeUpdateWithWhereUniqueWithoutProjectInput>
  updateMany?: ContributorAttributeUpdateManyWithWhereNestedInput | Enumerable<ContributorAttributeUpdateManyWithWhereNestedInput>
  deleteMany?: ContributorAttributeScalarWhereInput | Enumerable<ContributorAttributeScalarWhereInput>
  upsert?: ContributorAttributeUpsertWithWhereUniqueWithoutProjectInput | Enumerable<ContributorAttributeUpsertWithWhereUniqueWithoutProjectInput>
}

export type DiscoveryUpdateManyWithoutProjectInput = {
  create?: DiscoveryCreateWithoutProjectInput | Enumerable<DiscoveryCreateWithoutProjectInput>
  connect?: DiscoveryWhereUniqueInput | Enumerable<DiscoveryWhereUniqueInput>
  set?: DiscoveryWhereUniqueInput | Enumerable<DiscoveryWhereUniqueInput>
  disconnect?: DiscoveryWhereUniqueInput | Enumerable<DiscoveryWhereUniqueInput>
  delete?: DiscoveryWhereUniqueInput | Enumerable<DiscoveryWhereUniqueInput>
  update?: DiscoveryUpdateWithWhereUniqueWithoutProjectInput | Enumerable<DiscoveryUpdateWithWhereUniqueWithoutProjectInput>
  updateMany?: DiscoveryUpdateManyWithWhereNestedInput | Enumerable<DiscoveryUpdateManyWithWhereNestedInput>
  deleteMany?: DiscoveryScalarWhereInput | Enumerable<DiscoveryScalarWhereInput>
  upsert?: DiscoveryUpsertWithWhereUniqueWithoutProjectInput | Enumerable<DiscoveryUpsertWithWhereUniqueWithoutProjectInput>
}

export type MessageUpdateManyWithoutProjectInput = {
  create?: MessageCreateWithoutProjectInput | Enumerable<MessageCreateWithoutProjectInput>
  connect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  set?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  disconnect?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  delete?: MessageWhereUniqueInput | Enumerable<MessageWhereUniqueInput>
  update?: MessageUpdateWithWhereUniqueWithoutProjectInput | Enumerable<MessageUpdateWithWhereUniqueWithoutProjectInput>
  updateMany?: MessageUpdateManyWithWhereNestedInput | Enumerable<MessageUpdateManyWithWhereNestedInput>
  deleteMany?: MessageScalarWhereInput | Enumerable<MessageScalarWhereInput>
  upsert?: MessageUpsertWithWhereUniqueWithoutProjectInput | Enumerable<MessageUpsertWithWhereUniqueWithoutProjectInput>
}

export type OrganizationUpdateManyWithoutProjectInput = {
  create?: OrganizationCreateWithoutProjectInput | Enumerable<OrganizationCreateWithoutProjectInput>
  connect?: OrganizationWhereUniqueInput | Enumerable<OrganizationWhereUniqueInput>
  set?: OrganizationWhereUniqueInput | Enumerable<OrganizationWhereUniqueInput>
  disconnect?: OrganizationWhereUniqueInput | Enumerable<OrganizationWhereUniqueInput>
  delete?: OrganizationWhereUniqueInput | Enumerable<OrganizationWhereUniqueInput>
  update?: OrganizationUpdateWithWhereUniqueWithoutProjectInput | Enumerable<OrganizationUpdateWithWhereUniqueWithoutProjectInput>
  updateMany?: OrganizationUpdateManyWithWhereNestedInput | Enumerable<OrganizationUpdateManyWithWhereNestedInput>
  deleteMany?: OrganizationScalarWhereInput | Enumerable<OrganizationScalarWhereInput>
  upsert?: OrganizationUpsertWithWhereUniqueWithoutProjectInput | Enumerable<OrganizationUpsertWithWhereUniqueWithoutProjectInput>
}

export type PersonUpdateManyWithoutProjectInput = {
  create?: PersonCreateWithoutProjectInput | Enumerable<PersonCreateWithoutProjectInput>
  connect?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  set?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  disconnect?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  delete?: PersonWhereUniqueInput | Enumerable<PersonWhereUniqueInput>
  update?: PersonUpdateWithWhereUniqueWithoutProjectInput | Enumerable<PersonUpdateWithWhereUniqueWithoutProjectInput>
  updateMany?: PersonUpdateManyWithWhereNestedInput | Enumerable<PersonUpdateManyWithWhereNestedInput>
  deleteMany?: PersonScalarWhereInput | Enumerable<PersonScalarWhereInput>
  upsert?: PersonUpsertWithWhereUniqueWithoutProjectInput | Enumerable<PersonUpsertWithWhereUniqueWithoutProjectInput>
}

export type MessageCreateOneWithoutSubMessagesInput = {
  create?: MessageCreateWithoutSubMessagesInput
  connect?: MessageWhereUniqueInput
}

export type PersonCreateOneWithoutSubMessagesInput = {
  create?: PersonCreateWithoutSubMessagesInput
  connect?: PersonWhereUniqueInput
}

export type MessageUpdateOneRequiredWithoutSubMessagesInput = {
  create?: MessageCreateWithoutSubMessagesInput
  connect?: MessageWhereUniqueInput
  update?: MessageUpdateWithoutSubMessagesDataInput
  upsert?: MessageUpsertWithoutSubMessagesInput
}

export type PersonUpdateOneRequiredWithoutSubMessagesInput = {
  create?: PersonCreateWithoutSubMessagesInput
  connect?: PersonWhereUniqueInput
  update?: PersonUpdateWithoutSubMessagesDataInput
  upsert?: PersonUpsertWithoutSubMessagesInput
}

export type ChunkCreateOneWithoutTextSelectionsInput = {
  create?: ChunkCreateWithoutTextSelectionsInput
  connect?: ChunkWhereUniqueInput
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type ChunkUpdateOneRequiredWithoutTextSelectionsInput = {
  create?: ChunkCreateWithoutTextSelectionsInput
  connect?: ChunkWhereUniqueInput
  update?: ChunkUpdateWithoutTextSelectionsDataInput
  upsert?: ChunkUpsertWithoutTextSelectionsInput
}

export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type NestedEnumACCOUNT_TYPENullableFilter = {
  equals?: ACCOUNT_TYPE | null
  in?: Enumerable<ACCOUNT_TYPE> | null
  notIn?: Enumerable<ACCOUNT_TYPE> | null
  not?: ACCOUNT_TYPE | NestedEnumACCOUNT_TYPENullableFilter | null
}

export type NestedEnumENTITY_TYPENullableFilter = {
  equals?: ENTITY_TYPE | null
  in?: Enumerable<ENTITY_TYPE> | null
  notIn?: Enumerable<ENTITY_TYPE> | null
  not?: ENTITY_TYPE | NestedEnumENTITY_TYPENullableFilter | null
}

export type NestedEnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter = {
  equals?: CONTRIBUTOR_ATTRIBUTE_TYPE
  in?: Enumerable<CONTRIBUTOR_ATTRIBUTE_TYPE>
  notIn?: Enumerable<CONTRIBUTOR_ATTRIBUTE_TYPE>
  not?: CONTRIBUTOR_ATTRIBUTE_TYPE | NestedEnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringNullableFilter | null
}

export type NestedFloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type PersonCreateWithoutAccountsInput = {
  name: string
  email: string
  organization: OrganizationCreateOneWithoutPersonsInput
  project: ProjectCreateOneWithoutPersonsInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageCreateManyWithoutPersonInput
}

export type ProjectCreateWithoutAccountsInput = {
  name: string
  chunks?: ChunkCreateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeCreateManyWithoutProjectInput
  discoverys?: DiscoveryCreateManyWithoutProjectInput
  messages?: MessageCreateManyWithoutProjectInput
  organizations?: OrganizationCreateManyWithoutProjectInput
  persons?: PersonCreateManyWithoutProjectInput
}

export type PersonUpdateWithoutAccountsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  organization?: OrganizationUpdateOneRequiredWithoutPersonsInput
  project?: ProjectUpdateOneRequiredWithoutPersonsInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageUpdateManyWithoutPersonInput
}

export type PersonUpsertWithoutAccountsInput = {
  update: PersonUpdateWithoutAccountsDataInput
  create: PersonCreateWithoutAccountsInput
}

export type ProjectUpdateWithoutAccountsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  chunks?: ChunkUpdateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeUpdateManyWithoutProjectInput
  discoverys?: DiscoveryUpdateManyWithoutProjectInput
  messages?: MessageUpdateManyWithoutProjectInput
  organizations?: OrganizationUpdateManyWithoutProjectInput
  persons?: PersonUpdateManyWithoutProjectInput
}

export type ProjectUpsertWithoutAccountsInput = {
  update: ProjectUpdateWithoutAccountsDataInput
  create: ProjectCreateWithoutAccountsInput
}

export type DiscoveryCreateWithoutChunksInput = {
  title: string
  description?: string | null
  project: ProjectCreateOneWithoutDiscoverysInput
}

export type MessageCreateWithoutChunksInput = {
  clientId?: string | null
  title?: string | null
  content?: string | null
  project: ProjectCreateOneWithoutMessagesInput
  person_Message_requesterIdToPerson: PersonCreateOneWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson: PersonCreateOneWithoutMessage_Message_submitterIdToPersonsInput
  subMessages?: SubMessageCreateManyWithoutMessageInput
}

export type ProjectCreateWithoutChunksInput = {
  name: string
  accounts?: AccountCreateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeCreateManyWithoutProjectInput
  discoverys?: DiscoveryCreateManyWithoutProjectInput
  messages?: MessageCreateManyWithoutProjectInput
  organizations?: OrganizationCreateManyWithoutProjectInput
  persons?: PersonCreateManyWithoutProjectInput
}

export type TextSelectionCreateWithoutChunkInput = {
  offsetstart: number
  length: number
  submessagenumber: number
  content: string
}

export type DiscoveryUpdateWithoutChunksDataInput = {
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutDiscoverysInput
}

export type DiscoveryUpsertWithoutChunksInput = {
  update: DiscoveryUpdateWithoutChunksDataInput
  create: DiscoveryCreateWithoutChunksInput
}

export type MessageUpdateWithoutChunksDataInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutMessagesInput
  person_Message_requesterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_submitterIdToPersonsInput
  subMessages?: SubMessageUpdateManyWithoutMessageInput
}

export type MessageUpsertWithoutChunksInput = {
  update: MessageUpdateWithoutChunksDataInput
  create: MessageCreateWithoutChunksInput
}

export type ProjectUpdateWithoutChunksDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  accounts?: AccountUpdateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeUpdateManyWithoutProjectInput
  discoverys?: DiscoveryUpdateManyWithoutProjectInput
  messages?: MessageUpdateManyWithoutProjectInput
  organizations?: OrganizationUpdateManyWithoutProjectInput
  persons?: PersonUpdateManyWithoutProjectInput
}

export type ProjectUpsertWithoutChunksInput = {
  update: ProjectUpdateWithoutChunksDataInput
  create: ProjectCreateWithoutChunksInput
}

export type TextSelectionUpdateWithWhereUniqueWithoutChunkInput = {
  where: TextSelectionWhereUniqueInput
  data: TextSelectionUpdateWithoutChunkDataInput
}

export type TextSelectionUpdateManyWithWhereNestedInput = {
  where: TextSelectionScalarWhereInput
  data: TextSelectionUpdateManyDataInput
}

export type TextSelectionScalarWhereInput = {
  AND?: TextSelectionScalarWhereInput | Enumerable<TextSelectionScalarWhereInput>
  OR?: TextSelectionScalarWhereInput | Enumerable<TextSelectionScalarWhereInput>
  NOT?: TextSelectionScalarWhereInput | Enumerable<TextSelectionScalarWhereInput>
  id?: IntFilter | number
  offsetstart?: FloatFilter | number
  length?: FloatFilter | number
  submessagenumber?: IntFilter | number
  content?: StringFilter | string
  chunkId?: IntFilter | number
}

export type TextSelectionUpsertWithWhereUniqueWithoutChunkInput = {
  where: TextSelectionWhereUniqueInput
  update: TextSelectionUpdateWithoutChunkDataInput
  create: TextSelectionCreateWithoutChunkInput
}

export type ProjectCreateWithoutContributorAttributesInput = {
  name: string
  accounts?: AccountCreateManyWithoutProjectInput
  chunks?: ChunkCreateManyWithoutProjectInput
  discoverys?: DiscoveryCreateManyWithoutProjectInput
  messages?: MessageCreateManyWithoutProjectInput
  organizations?: OrganizationCreateManyWithoutProjectInput
  persons?: PersonCreateManyWithoutProjectInput
}

export type ContributorAttributeValueCreateWithoutContributorAttributeInput = {
  valuetext?: string | null
  organization: OrganizationCreateOneWithoutContributorAttributeValuesInput
  person: PersonCreateOneWithoutContributorAttributeValuesInput
}

export type ProjectUpdateWithoutContributorAttributesDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  accounts?: AccountUpdateManyWithoutProjectInput
  chunks?: ChunkUpdateManyWithoutProjectInput
  discoverys?: DiscoveryUpdateManyWithoutProjectInput
  messages?: MessageUpdateManyWithoutProjectInput
  organizations?: OrganizationUpdateManyWithoutProjectInput
  persons?: PersonUpdateManyWithoutProjectInput
}

export type ProjectUpsertWithoutContributorAttributesInput = {
  update: ProjectUpdateWithoutContributorAttributesDataInput
  create: ProjectCreateWithoutContributorAttributesInput
}

export type ContributorAttributeValueUpdateWithWhereUniqueWithoutContributorAttributeInput = {
  where: ContributorAttributeValueWhereUniqueInput
  data: ContributorAttributeValueUpdateWithoutContributorAttributeDataInput
}

export type ContributorAttributeValueUpdateManyWithWhereNestedInput = {
  where: ContributorAttributeValueScalarWhereInput
  data: ContributorAttributeValueUpdateManyDataInput
}

export type ContributorAttributeValueScalarWhereInput = {
  AND?: ContributorAttributeValueScalarWhereInput | Enumerable<ContributorAttributeValueScalarWhereInput>
  OR?: ContributorAttributeValueScalarWhereInput | Enumerable<ContributorAttributeValueScalarWhereInput>
  NOT?: ContributorAttributeValueScalarWhereInput | Enumerable<ContributorAttributeValueScalarWhereInput>
  id?: IntFilter | number
  contributorAttributeId?: IntFilter | number
  contributorAttributeType?: EnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter | CONTRIBUTOR_ATTRIBUTE_TYPE
  personId?: IntFilter | number
  organizationId?: IntFilter | number
  valuetext?: StringNullableFilter | string | null
}

export type ContributorAttributeValueUpsertWithWhereUniqueWithoutContributorAttributeInput = {
  where: ContributorAttributeValueWhereUniqueInput
  update: ContributorAttributeValueUpdateWithoutContributorAttributeDataInput
  create: ContributorAttributeValueCreateWithoutContributorAttributeInput
}

export type ContributorAttributeCreateWithoutContributorAttributeValuesInput = {
  id?: number
  appliesTo?: ENTITY_TYPE | null
  name: string
  type: CONTRIBUTOR_ATTRIBUTE_TYPE
  project: ProjectCreateOneWithoutContributorAttributesInput
}

export type OrganizationCreateWithoutContributorAttributeValuesInput = {
  name: string
  project: ProjectCreateOneWithoutOrganizationsInput
  persons?: PersonCreateManyWithoutOrganizationInput
}

export type PersonCreateWithoutContributorAttributeValuesInput = {
  name: string
  email: string
  organization: OrganizationCreateOneWithoutPersonsInput
  project: ProjectCreateOneWithoutPersonsInput
  accounts?: AccountCreateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageCreateManyWithoutPersonInput
}

export type ContributorAttributeUpdateWithoutContributorAttributeValuesDataInput = {
  id?: number | IntFieldUpdateOperationsInput
  appliesTo?: ENTITY_TYPE | NullableEnumENTITY_TYPEFieldUpdateOperationsInput | null
  name?: string | StringFieldUpdateOperationsInput
  type?: CONTRIBUTOR_ATTRIBUTE_TYPE | EnumCONTRIBUTOR_ATTRIBUTE_TYPEFieldUpdateOperationsInput
  project?: ProjectUpdateOneRequiredWithoutContributorAttributesInput
}

export type ContributorAttributeUpsertWithoutContributorAttributeValuesInput = {
  update: ContributorAttributeUpdateWithoutContributorAttributeValuesDataInput
  create: ContributorAttributeCreateWithoutContributorAttributeValuesInput
}

export type OrganizationUpdateWithoutContributorAttributeValuesDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  project?: ProjectUpdateOneRequiredWithoutOrganizationsInput
  persons?: PersonUpdateManyWithoutOrganizationInput
}

export type OrganizationUpsertWithoutContributorAttributeValuesInput = {
  update: OrganizationUpdateWithoutContributorAttributeValuesDataInput
  create: OrganizationCreateWithoutContributorAttributeValuesInput
}

export type PersonUpdateWithoutContributorAttributeValuesDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  organization?: OrganizationUpdateOneRequiredWithoutPersonsInput
  project?: ProjectUpdateOneRequiredWithoutPersonsInput
  accounts?: AccountUpdateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageUpdateManyWithoutPersonInput
}

export type PersonUpsertWithoutContributorAttributeValuesInput = {
  update: PersonUpdateWithoutContributorAttributeValuesDataInput
  create: PersonCreateWithoutContributorAttributeValuesInput
}

export type ProjectCreateWithoutDiscoverysInput = {
  name: string
  accounts?: AccountCreateManyWithoutProjectInput
  chunks?: ChunkCreateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeCreateManyWithoutProjectInput
  messages?: MessageCreateManyWithoutProjectInput
  organizations?: OrganizationCreateManyWithoutProjectInput
  persons?: PersonCreateManyWithoutProjectInput
}

export type ChunkCreateWithoutDiscoveryInput = {
  message: MessageCreateOneWithoutChunksInput
  project: ProjectCreateOneWithoutChunksInput
  textSelections?: TextSelectionCreateManyWithoutChunkInput
}

export type ProjectUpdateWithoutDiscoverysDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  accounts?: AccountUpdateManyWithoutProjectInput
  chunks?: ChunkUpdateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeUpdateManyWithoutProjectInput
  messages?: MessageUpdateManyWithoutProjectInput
  organizations?: OrganizationUpdateManyWithoutProjectInput
  persons?: PersonUpdateManyWithoutProjectInput
}

export type ProjectUpsertWithoutDiscoverysInput = {
  update: ProjectUpdateWithoutDiscoverysDataInput
  create: ProjectCreateWithoutDiscoverysInput
}

export type ChunkUpdateWithWhereUniqueWithoutDiscoveryInput = {
  where: ChunkWhereUniqueInput
  data: ChunkUpdateWithoutDiscoveryDataInput
}

export type ChunkUpdateManyWithWhereNestedInput = {
  where: ChunkScalarWhereInput
  data: ChunkUpdateManyDataInput
}

export type ChunkScalarWhereInput = {
  AND?: ChunkScalarWhereInput | Enumerable<ChunkScalarWhereInput>
  OR?: ChunkScalarWhereInput | Enumerable<ChunkScalarWhereInput>
  NOT?: ChunkScalarWhereInput | Enumerable<ChunkScalarWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  messageId?: IntFilter | number
  discoveryId?: IntFilter | number
}

export type ChunkUpsertWithWhereUniqueWithoutDiscoveryInput = {
  where: ChunkWhereUniqueInput
  update: ChunkUpdateWithoutDiscoveryDataInput
  create: ChunkCreateWithoutDiscoveryInput
}

export type ProjectCreateWithoutMessagesInput = {
  name: string
  accounts?: AccountCreateManyWithoutProjectInput
  chunks?: ChunkCreateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeCreateManyWithoutProjectInput
  discoverys?: DiscoveryCreateManyWithoutProjectInput
  organizations?: OrganizationCreateManyWithoutProjectInput
  persons?: PersonCreateManyWithoutProjectInput
}

export type PersonCreateWithoutMessage_Message_requesterIdToPersonsInput = {
  name: string
  email: string
  organization: OrganizationCreateOneWithoutPersonsInput
  project: ProjectCreateOneWithoutPersonsInput
  accounts?: AccountCreateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutPersonInput
  message_Message_submitterIdToPersons?: MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageCreateManyWithoutPersonInput
}

export type PersonCreateWithoutMessage_Message_submitterIdToPersonsInput = {
  name: string
  email: string
  organization: OrganizationCreateOneWithoutPersonsInput
  project: ProjectCreateOneWithoutPersonsInput
  accounts?: AccountCreateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput
  subMessages?: SubMessageCreateManyWithoutPersonInput
}

export type ChunkCreateWithoutMessageInput = {
  discovery: DiscoveryCreateOneWithoutChunksInput
  project: ProjectCreateOneWithoutChunksInput
  textSelections?: TextSelectionCreateManyWithoutChunkInput
}

export type SubMessageCreateWithoutMessageInput = {
  content: string
  person: PersonCreateOneWithoutSubMessagesInput
}

export type ProjectUpdateWithoutMessagesDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  accounts?: AccountUpdateManyWithoutProjectInput
  chunks?: ChunkUpdateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeUpdateManyWithoutProjectInput
  discoverys?: DiscoveryUpdateManyWithoutProjectInput
  organizations?: OrganizationUpdateManyWithoutProjectInput
  persons?: PersonUpdateManyWithoutProjectInput
}

export type ProjectUpsertWithoutMessagesInput = {
  update: ProjectUpdateWithoutMessagesDataInput
  create: ProjectCreateWithoutMessagesInput
}

export type PersonUpdateWithoutMessage_Message_requesterIdToPersonsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  organization?: OrganizationUpdateOneRequiredWithoutPersonsInput
  project?: ProjectUpdateOneRequiredWithoutPersonsInput
  accounts?: AccountUpdateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutPersonInput
  message_Message_submitterIdToPersons?: MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageUpdateManyWithoutPersonInput
}

export type PersonUpsertWithoutMessage_Message_requesterIdToPersonsInput = {
  update: PersonUpdateWithoutMessage_Message_requesterIdToPersonsDataInput
  create: PersonCreateWithoutMessage_Message_requesterIdToPersonsInput
}

export type PersonUpdateWithoutMessage_Message_submitterIdToPersonsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  organization?: OrganizationUpdateOneRequiredWithoutPersonsInput
  project?: ProjectUpdateOneRequiredWithoutPersonsInput
  accounts?: AccountUpdateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput
  subMessages?: SubMessageUpdateManyWithoutPersonInput
}

export type PersonUpsertWithoutMessage_Message_submitterIdToPersonsInput = {
  update: PersonUpdateWithoutMessage_Message_submitterIdToPersonsDataInput
  create: PersonCreateWithoutMessage_Message_submitterIdToPersonsInput
}

export type ChunkUpdateWithWhereUniqueWithoutMessageInput = {
  where: ChunkWhereUniqueInput
  data: ChunkUpdateWithoutMessageDataInput
}

export type ChunkUpsertWithWhereUniqueWithoutMessageInput = {
  where: ChunkWhereUniqueInput
  update: ChunkUpdateWithoutMessageDataInput
  create: ChunkCreateWithoutMessageInput
}

export type SubMessageUpdateWithWhereUniqueWithoutMessageInput = {
  where: SubMessageWhereUniqueInput
  data: SubMessageUpdateWithoutMessageDataInput
}

export type SubMessageUpdateManyWithWhereNestedInput = {
  where: SubMessageScalarWhereInput
  data: SubMessageUpdateManyDataInput
}

export type SubMessageScalarWhereInput = {
  AND?: SubMessageScalarWhereInput | Enumerable<SubMessageScalarWhereInput>
  OR?: SubMessageScalarWhereInput | Enumerable<SubMessageScalarWhereInput>
  NOT?: SubMessageScalarWhereInput | Enumerable<SubMessageScalarWhereInput>
  id?: IntFilter | number
  submitterId?: IntFilter | number
  content?: StringFilter | string
  messageId?: IntFilter | number
}

export type SubMessageUpsertWithWhereUniqueWithoutMessageInput = {
  where: SubMessageWhereUniqueInput
  update: SubMessageUpdateWithoutMessageDataInput
  create: SubMessageCreateWithoutMessageInput
}

export type ProjectCreateWithoutOrganizationsInput = {
  name: string
  accounts?: AccountCreateManyWithoutProjectInput
  chunks?: ChunkCreateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeCreateManyWithoutProjectInput
  discoverys?: DiscoveryCreateManyWithoutProjectInput
  messages?: MessageCreateManyWithoutProjectInput
  persons?: PersonCreateManyWithoutProjectInput
}

export type ContributorAttributeValueCreateWithoutOrganizationInput = {
  valuetext?: string | null
  contributorAttribute: ContributorAttributeCreateOneWithoutContributorAttributeValuesInput
  person: PersonCreateOneWithoutContributorAttributeValuesInput
}

export type PersonCreateWithoutOrganizationInput = {
  name: string
  email: string
  project: ProjectCreateOneWithoutPersonsInput
  accounts?: AccountCreateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageCreateManyWithoutPersonInput
}

export type ProjectUpdateWithoutOrganizationsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  accounts?: AccountUpdateManyWithoutProjectInput
  chunks?: ChunkUpdateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeUpdateManyWithoutProjectInput
  discoverys?: DiscoveryUpdateManyWithoutProjectInput
  messages?: MessageUpdateManyWithoutProjectInput
  persons?: PersonUpdateManyWithoutProjectInput
}

export type ProjectUpsertWithoutOrganizationsInput = {
  update: ProjectUpdateWithoutOrganizationsDataInput
  create: ProjectCreateWithoutOrganizationsInput
}

export type ContributorAttributeValueUpdateWithWhereUniqueWithoutOrganizationInput = {
  where: ContributorAttributeValueWhereUniqueInput
  data: ContributorAttributeValueUpdateWithoutOrganizationDataInput
}

export type ContributorAttributeValueUpsertWithWhereUniqueWithoutOrganizationInput = {
  where: ContributorAttributeValueWhereUniqueInput
  update: ContributorAttributeValueUpdateWithoutOrganizationDataInput
  create: ContributorAttributeValueCreateWithoutOrganizationInput
}

export type PersonUpdateWithWhereUniqueWithoutOrganizationInput = {
  where: PersonWhereUniqueInput
  data: PersonUpdateWithoutOrganizationDataInput
}

export type PersonUpdateManyWithWhereNestedInput = {
  where: PersonScalarWhereInput
  data: PersonUpdateManyDataInput
}

export type PersonScalarWhereInput = {
  AND?: PersonScalarWhereInput | Enumerable<PersonScalarWhereInput>
  OR?: PersonScalarWhereInput | Enumerable<PersonScalarWhereInput>
  NOT?: PersonScalarWhereInput | Enumerable<PersonScalarWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  name?: StringFilter | string
  email?: StringFilter | string
  organizationId?: IntFilter | number
}

export type PersonUpsertWithWhereUniqueWithoutOrganizationInput = {
  where: PersonWhereUniqueInput
  update: PersonUpdateWithoutOrganizationDataInput
  create: PersonCreateWithoutOrganizationInput
}

export type OrganizationCreateWithoutPersonsInput = {
  name: string
  project: ProjectCreateOneWithoutOrganizationsInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutOrganizationInput
}

export type ProjectCreateWithoutPersonsInput = {
  name: string
  accounts?: AccountCreateManyWithoutProjectInput
  chunks?: ChunkCreateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeCreateManyWithoutProjectInput
  discoverys?: DiscoveryCreateManyWithoutProjectInput
  messages?: MessageCreateManyWithoutProjectInput
  organizations?: OrganizationCreateManyWithoutProjectInput
}

export type AccountCreateWithoutPersonInput = {
  username: string
  hashedPassword: string
  type?: ACCOUNT_TYPE | null
  project: ProjectCreateOneWithoutAccountsInput
}

export type ContributorAttributeValueCreateWithoutPersonInput = {
  valuetext?: string | null
  contributorAttribute: ContributorAttributeCreateOneWithoutContributorAttributeValuesInput
  organization: OrganizationCreateOneWithoutContributorAttributeValuesInput
}

export type MessageCreateWithoutPerson_Message_requesterIdToPersonInput = {
  clientId?: string | null
  title?: string | null
  content?: string | null
  project: ProjectCreateOneWithoutMessagesInput
  person_Message_submitterIdToPerson: PersonCreateOneWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkCreateManyWithoutMessageInput
  subMessages?: SubMessageCreateManyWithoutMessageInput
}

export type MessageCreateWithoutPerson_Message_submitterIdToPersonInput = {
  clientId?: string | null
  title?: string | null
  content?: string | null
  project: ProjectCreateOneWithoutMessagesInput
  person_Message_requesterIdToPerson: PersonCreateOneWithoutMessage_Message_requesterIdToPersonsInput
  chunks?: ChunkCreateManyWithoutMessageInput
  subMessages?: SubMessageCreateManyWithoutMessageInput
}

export type SubMessageCreateWithoutPersonInput = {
  content: string
  message: MessageCreateOneWithoutSubMessagesInput
}

export type OrganizationUpdateWithoutPersonsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  project?: ProjectUpdateOneRequiredWithoutOrganizationsInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutOrganizationInput
}

export type OrganizationUpsertWithoutPersonsInput = {
  update: OrganizationUpdateWithoutPersonsDataInput
  create: OrganizationCreateWithoutPersonsInput
}

export type ProjectUpdateWithoutPersonsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  accounts?: AccountUpdateManyWithoutProjectInput
  chunks?: ChunkUpdateManyWithoutProjectInput
  contributorAttributes?: ContributorAttributeUpdateManyWithoutProjectInput
  discoverys?: DiscoveryUpdateManyWithoutProjectInput
  messages?: MessageUpdateManyWithoutProjectInput
  organizations?: OrganizationUpdateManyWithoutProjectInput
}

export type ProjectUpsertWithoutPersonsInput = {
  update: ProjectUpdateWithoutPersonsDataInput
  create: ProjectCreateWithoutPersonsInput
}

export type AccountUpdateWithWhereUniqueWithoutPersonInput = {
  where: AccountWhereUniqueInput
  data: AccountUpdateWithoutPersonDataInput
}

export type AccountUpdateManyWithWhereNestedInput = {
  where: AccountScalarWhereInput
  data: AccountUpdateManyDataInput
}

export type AccountScalarWhereInput = {
  AND?: AccountScalarWhereInput | Enumerable<AccountScalarWhereInput>
  OR?: AccountScalarWhereInput | Enumerable<AccountScalarWhereInput>
  NOT?: AccountScalarWhereInput | Enumerable<AccountScalarWhereInput>
  id?: IntFilter | number
  username?: StringFilter | string
  hashedPassword?: StringFilter | string
  personId?: IntFilter | number
  projectId?: IntFilter | number
  type?: EnumACCOUNT_TYPENullableFilter | ACCOUNT_TYPE | null
}

export type AccountUpsertWithWhereUniqueWithoutPersonInput = {
  where: AccountWhereUniqueInput
  update: AccountUpdateWithoutPersonDataInput
  create: AccountCreateWithoutPersonInput
}

export type ContributorAttributeValueUpdateWithWhereUniqueWithoutPersonInput = {
  where: ContributorAttributeValueWhereUniqueInput
  data: ContributorAttributeValueUpdateWithoutPersonDataInput
}

export type ContributorAttributeValueUpsertWithWhereUniqueWithoutPersonInput = {
  where: ContributorAttributeValueWhereUniqueInput
  update: ContributorAttributeValueUpdateWithoutPersonDataInput
  create: ContributorAttributeValueCreateWithoutPersonInput
}

export type MessageUpdateWithWhereUniqueWithoutPerson_Message_requesterIdToPersonInput = {
  where: MessageWhereUniqueInput
  data: MessageUpdateWithoutPerson_Message_requesterIdToPersonDataInput
}

export type MessageUpdateManyWithWhereNestedInput = {
  where: MessageScalarWhereInput
  data: MessageUpdateManyDataInput
}

export type MessageScalarWhereInput = {
  AND?: MessageScalarWhereInput | Enumerable<MessageScalarWhereInput>
  OR?: MessageScalarWhereInput | Enumerable<MessageScalarWhereInput>
  NOT?: MessageScalarWhereInput | Enumerable<MessageScalarWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  requesterId?: IntFilter | number
  submitterId?: IntFilter | number
  clientId?: StringNullableFilter | string | null
  title?: StringNullableFilter | string | null
  content?: StringNullableFilter | string | null
}

export type MessageUpsertWithWhereUniqueWithoutPerson_Message_requesterIdToPersonInput = {
  where: MessageWhereUniqueInput
  update: MessageUpdateWithoutPerson_Message_requesterIdToPersonDataInput
  create: MessageCreateWithoutPerson_Message_requesterIdToPersonInput
}

export type MessageUpdateWithWhereUniqueWithoutPerson_Message_submitterIdToPersonInput = {
  where: MessageWhereUniqueInput
  data: MessageUpdateWithoutPerson_Message_submitterIdToPersonDataInput
}

export type MessageUpsertWithWhereUniqueWithoutPerson_Message_submitterIdToPersonInput = {
  where: MessageWhereUniqueInput
  update: MessageUpdateWithoutPerson_Message_submitterIdToPersonDataInput
  create: MessageCreateWithoutPerson_Message_submitterIdToPersonInput
}

export type SubMessageUpdateWithWhereUniqueWithoutPersonInput = {
  where: SubMessageWhereUniqueInput
  data: SubMessageUpdateWithoutPersonDataInput
}

export type SubMessageUpsertWithWhereUniqueWithoutPersonInput = {
  where: SubMessageWhereUniqueInput
  update: SubMessageUpdateWithoutPersonDataInput
  create: SubMessageCreateWithoutPersonInput
}

export type AccountCreateWithoutProjectInput = {
  username: string
  hashedPassword: string
  type?: ACCOUNT_TYPE | null
  person: PersonCreateOneWithoutAccountsInput
}

export type ChunkCreateWithoutProjectInput = {
  discovery: DiscoveryCreateOneWithoutChunksInput
  message: MessageCreateOneWithoutChunksInput
  textSelections?: TextSelectionCreateManyWithoutChunkInput
}

export type ContributorAttributeCreateWithoutProjectInput = {
  id?: number
  appliesTo?: ENTITY_TYPE | null
  name: string
  type: CONTRIBUTOR_ATTRIBUTE_TYPE
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutContributorAttributeInput
}

export type DiscoveryCreateWithoutProjectInput = {
  title: string
  description?: string | null
  chunks?: ChunkCreateManyWithoutDiscoveryInput
}

export type MessageCreateWithoutProjectInput = {
  clientId?: string | null
  title?: string | null
  content?: string | null
  person_Message_requesterIdToPerson: PersonCreateOneWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson: PersonCreateOneWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkCreateManyWithoutMessageInput
  subMessages?: SubMessageCreateManyWithoutMessageInput
}

export type OrganizationCreateWithoutProjectInput = {
  name: string
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutOrganizationInput
  persons?: PersonCreateManyWithoutOrganizationInput
}

export type PersonCreateWithoutProjectInput = {
  name: string
  email: string
  organization: OrganizationCreateOneWithoutPersonsInput
  accounts?: AccountCreateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageCreateManyWithoutPersonInput
}

export type AccountUpdateWithWhereUniqueWithoutProjectInput = {
  where: AccountWhereUniqueInput
  data: AccountUpdateWithoutProjectDataInput
}

export type AccountUpsertWithWhereUniqueWithoutProjectInput = {
  where: AccountWhereUniqueInput
  update: AccountUpdateWithoutProjectDataInput
  create: AccountCreateWithoutProjectInput
}

export type ChunkUpdateWithWhereUniqueWithoutProjectInput = {
  where: ChunkWhereUniqueInput
  data: ChunkUpdateWithoutProjectDataInput
}

export type ChunkUpsertWithWhereUniqueWithoutProjectInput = {
  where: ChunkWhereUniqueInput
  update: ChunkUpdateWithoutProjectDataInput
  create: ChunkCreateWithoutProjectInput
}

export type ContributorAttributeUpdateWithWhereUniqueWithoutProjectInput = {
  where: ContributorAttributeWhereUniqueInput
  data: ContributorAttributeUpdateWithoutProjectDataInput
}

export type ContributorAttributeUpdateManyWithWhereNestedInput = {
  where: ContributorAttributeScalarWhereInput
  data: ContributorAttributeUpdateManyDataInput
}

export type ContributorAttributeScalarWhereInput = {
  AND?: ContributorAttributeScalarWhereInput | Enumerable<ContributorAttributeScalarWhereInput>
  OR?: ContributorAttributeScalarWhereInput | Enumerable<ContributorAttributeScalarWhereInput>
  NOT?: ContributorAttributeScalarWhereInput | Enumerable<ContributorAttributeScalarWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  appliesTo?: EnumENTITY_TYPENullableFilter | ENTITY_TYPE | null
  name?: StringFilter | string
  type?: EnumCONTRIBUTOR_ATTRIBUTE_TYPEFilter | CONTRIBUTOR_ATTRIBUTE_TYPE
}

export type ContributorAttributeUpsertWithWhereUniqueWithoutProjectInput = {
  where: ContributorAttributeWhereUniqueInput
  update: ContributorAttributeUpdateWithoutProjectDataInput
  create: ContributorAttributeCreateWithoutProjectInput
}

export type DiscoveryUpdateWithWhereUniqueWithoutProjectInput = {
  where: DiscoveryWhereUniqueInput
  data: DiscoveryUpdateWithoutProjectDataInput
}

export type DiscoveryUpdateManyWithWhereNestedInput = {
  where: DiscoveryScalarWhereInput
  data: DiscoveryUpdateManyDataInput
}

export type DiscoveryScalarWhereInput = {
  AND?: DiscoveryScalarWhereInput | Enumerable<DiscoveryScalarWhereInput>
  OR?: DiscoveryScalarWhereInput | Enumerable<DiscoveryScalarWhereInput>
  NOT?: DiscoveryScalarWhereInput | Enumerable<DiscoveryScalarWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  title?: StringFilter | string
  description?: StringNullableFilter | string | null
}

export type DiscoveryUpsertWithWhereUniqueWithoutProjectInput = {
  where: DiscoveryWhereUniqueInput
  update: DiscoveryUpdateWithoutProjectDataInput
  create: DiscoveryCreateWithoutProjectInput
}

export type MessageUpdateWithWhereUniqueWithoutProjectInput = {
  where: MessageWhereUniqueInput
  data: MessageUpdateWithoutProjectDataInput
}

export type MessageUpsertWithWhereUniqueWithoutProjectInput = {
  where: MessageWhereUniqueInput
  update: MessageUpdateWithoutProjectDataInput
  create: MessageCreateWithoutProjectInput
}

export type OrganizationUpdateWithWhereUniqueWithoutProjectInput = {
  where: OrganizationWhereUniqueInput
  data: OrganizationUpdateWithoutProjectDataInput
}

export type OrganizationUpdateManyWithWhereNestedInput = {
  where: OrganizationScalarWhereInput
  data: OrganizationUpdateManyDataInput
}

export type OrganizationScalarWhereInput = {
  AND?: OrganizationScalarWhereInput | Enumerable<OrganizationScalarWhereInput>
  OR?: OrganizationScalarWhereInput | Enumerable<OrganizationScalarWhereInput>
  NOT?: OrganizationScalarWhereInput | Enumerable<OrganizationScalarWhereInput>
  projectId?: IntFilter | number
  id?: IntFilter | number
  name?: StringFilter | string
}

export type OrganizationUpsertWithWhereUniqueWithoutProjectInput = {
  where: OrganizationWhereUniqueInput
  update: OrganizationUpdateWithoutProjectDataInput
  create: OrganizationCreateWithoutProjectInput
}

export type PersonUpdateWithWhereUniqueWithoutProjectInput = {
  where: PersonWhereUniqueInput
  data: PersonUpdateWithoutProjectDataInput
}

export type PersonUpsertWithWhereUniqueWithoutProjectInput = {
  where: PersonWhereUniqueInput
  update: PersonUpdateWithoutProjectDataInput
  create: PersonCreateWithoutProjectInput
}

export type MessageCreateWithoutSubMessagesInput = {
  clientId?: string | null
  title?: string | null
  content?: string | null
  project: ProjectCreateOneWithoutMessagesInput
  person_Message_requesterIdToPerson: PersonCreateOneWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson: PersonCreateOneWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkCreateManyWithoutMessageInput
}

export type PersonCreateWithoutSubMessagesInput = {
  name: string
  email: string
  organization: OrganizationCreateOneWithoutPersonsInput
  project: ProjectCreateOneWithoutPersonsInput
  accounts?: AccountCreateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueCreateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageCreateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageCreateManyWithoutPerson_Message_submitterIdToPersonInput
}

export type MessageUpdateWithoutSubMessagesDataInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutMessagesInput
  person_Message_requesterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkUpdateManyWithoutMessageInput
}

export type MessageUpsertWithoutSubMessagesInput = {
  update: MessageUpdateWithoutSubMessagesDataInput
  create: MessageCreateWithoutSubMessagesInput
}

export type PersonUpdateWithoutSubMessagesDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  organization?: OrganizationUpdateOneRequiredWithoutPersonsInput
  project?: ProjectUpdateOneRequiredWithoutPersonsInput
  accounts?: AccountUpdateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput
}

export type PersonUpsertWithoutSubMessagesInput = {
  update: PersonUpdateWithoutSubMessagesDataInput
  create: PersonCreateWithoutSubMessagesInput
}

export type ChunkCreateWithoutTextSelectionsInput = {
  discovery: DiscoveryCreateOneWithoutChunksInput
  message: MessageCreateOneWithoutChunksInput
  project: ProjectCreateOneWithoutChunksInput
}

export type ChunkUpdateWithoutTextSelectionsDataInput = {
  discovery?: DiscoveryUpdateOneRequiredWithoutChunksInput
  message?: MessageUpdateOneRequiredWithoutChunksInput
  project?: ProjectUpdateOneRequiredWithoutChunksInput
}

export type ChunkUpsertWithoutTextSelectionsInput = {
  update: ChunkUpdateWithoutTextSelectionsDataInput
  create: ChunkCreateWithoutTextSelectionsInput
}

export type TextSelectionUpdateWithoutChunkDataInput = {
  offsetstart?: number | FloatFieldUpdateOperationsInput
  length?: number | FloatFieldUpdateOperationsInput
  submessagenumber?: number | IntFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
}

export type TextSelectionUpdateManyDataInput = {
  offsetstart?: number | FloatFieldUpdateOperationsInput
  length?: number | FloatFieldUpdateOperationsInput
  submessagenumber?: number | IntFieldUpdateOperationsInput
  content?: string | StringFieldUpdateOperationsInput
}

export type ContributorAttributeValueUpdateWithoutContributorAttributeDataInput = {
  valuetext?: string | NullableStringFieldUpdateOperationsInput | null
  organization?: OrganizationUpdateOneRequiredWithoutContributorAttributeValuesInput
  person?: PersonUpdateOneRequiredWithoutContributorAttributeValuesInput
}

export type ContributorAttributeValueUpdateManyDataInput = {
  valuetext?: string | NullableStringFieldUpdateOperationsInput | null
}

export type ChunkUpdateWithoutDiscoveryDataInput = {
  message?: MessageUpdateOneRequiredWithoutChunksInput
  project?: ProjectUpdateOneRequiredWithoutChunksInput
  textSelections?: TextSelectionUpdateManyWithoutChunkInput
}

export type ChunkUpdateManyDataInput = {

}

export type ChunkUpdateWithoutMessageDataInput = {
  discovery?: DiscoveryUpdateOneRequiredWithoutChunksInput
  project?: ProjectUpdateOneRequiredWithoutChunksInput
  textSelections?: TextSelectionUpdateManyWithoutChunkInput
}

export type SubMessageUpdateWithoutMessageDataInput = {
  content?: string | StringFieldUpdateOperationsInput
  person?: PersonUpdateOneRequiredWithoutSubMessagesInput
}

export type SubMessageUpdateManyDataInput = {
  content?: string | StringFieldUpdateOperationsInput
}

export type ContributorAttributeValueUpdateWithoutOrganizationDataInput = {
  valuetext?: string | NullableStringFieldUpdateOperationsInput | null
  contributorAttribute?: ContributorAttributeUpdateOneRequiredWithoutContributorAttributeValuesInput
  person?: PersonUpdateOneRequiredWithoutContributorAttributeValuesInput
}

export type PersonUpdateWithoutOrganizationDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  project?: ProjectUpdateOneRequiredWithoutPersonsInput
  accounts?: AccountUpdateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageUpdateManyWithoutPersonInput
}

export type PersonUpdateManyDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
}

export type AccountUpdateWithoutPersonDataInput = {
  username?: string | StringFieldUpdateOperationsInput
  hashedPassword?: string | StringFieldUpdateOperationsInput
  type?: ACCOUNT_TYPE | NullableEnumACCOUNT_TYPEFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutAccountsInput
}

export type AccountUpdateManyDataInput = {
  username?: string | StringFieldUpdateOperationsInput
  hashedPassword?: string | StringFieldUpdateOperationsInput
  type?: ACCOUNT_TYPE | NullableEnumACCOUNT_TYPEFieldUpdateOperationsInput | null
}

export type ContributorAttributeValueUpdateWithoutPersonDataInput = {
  valuetext?: string | NullableStringFieldUpdateOperationsInput | null
  contributorAttribute?: ContributorAttributeUpdateOneRequiredWithoutContributorAttributeValuesInput
  organization?: OrganizationUpdateOneRequiredWithoutContributorAttributeValuesInput
}

export type MessageUpdateWithoutPerson_Message_requesterIdToPersonDataInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutMessagesInput
  person_Message_submitterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkUpdateManyWithoutMessageInput
  subMessages?: SubMessageUpdateManyWithoutMessageInput
}

export type MessageUpdateManyDataInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
}

export type MessageUpdateWithoutPerson_Message_submitterIdToPersonDataInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
  project?: ProjectUpdateOneRequiredWithoutMessagesInput
  person_Message_requesterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_requesterIdToPersonsInput
  chunks?: ChunkUpdateManyWithoutMessageInput
  subMessages?: SubMessageUpdateManyWithoutMessageInput
}

export type SubMessageUpdateWithoutPersonDataInput = {
  content?: string | StringFieldUpdateOperationsInput
  message?: MessageUpdateOneRequiredWithoutSubMessagesInput
}

export type AccountUpdateWithoutProjectDataInput = {
  username?: string | StringFieldUpdateOperationsInput
  hashedPassword?: string | StringFieldUpdateOperationsInput
  type?: ACCOUNT_TYPE | NullableEnumACCOUNT_TYPEFieldUpdateOperationsInput | null
  person?: PersonUpdateOneRequiredWithoutAccountsInput
}

export type ChunkUpdateWithoutProjectDataInput = {
  discovery?: DiscoveryUpdateOneRequiredWithoutChunksInput
  message?: MessageUpdateOneRequiredWithoutChunksInput
  textSelections?: TextSelectionUpdateManyWithoutChunkInput
}

export type ContributorAttributeUpdateWithoutProjectDataInput = {
  id?: number | IntFieldUpdateOperationsInput
  appliesTo?: ENTITY_TYPE | NullableEnumENTITY_TYPEFieldUpdateOperationsInput | null
  name?: string | StringFieldUpdateOperationsInput
  type?: CONTRIBUTOR_ATTRIBUTE_TYPE | EnumCONTRIBUTOR_ATTRIBUTE_TYPEFieldUpdateOperationsInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutContributorAttributeInput
}

export type ContributorAttributeUpdateManyDataInput = {
  id?: number | IntFieldUpdateOperationsInput
  appliesTo?: ENTITY_TYPE | NullableEnumENTITY_TYPEFieldUpdateOperationsInput | null
  name?: string | StringFieldUpdateOperationsInput
  type?: CONTRIBUTOR_ATTRIBUTE_TYPE | EnumCONTRIBUTOR_ATTRIBUTE_TYPEFieldUpdateOperationsInput
}

export type DiscoveryUpdateWithoutProjectDataInput = {
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
  chunks?: ChunkUpdateManyWithoutDiscoveryInput
}

export type DiscoveryUpdateManyDataInput = {
  title?: string | StringFieldUpdateOperationsInput
  description?: string | NullableStringFieldUpdateOperationsInput | null
}

export type MessageUpdateWithoutProjectDataInput = {
  clientId?: string | NullableStringFieldUpdateOperationsInput | null
  title?: string | NullableStringFieldUpdateOperationsInput | null
  content?: string | NullableStringFieldUpdateOperationsInput | null
  person_Message_requesterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_requesterIdToPersonsInput
  person_Message_submitterIdToPerson?: PersonUpdateOneRequiredWithoutMessage_Message_submitterIdToPersonsInput
  chunks?: ChunkUpdateManyWithoutMessageInput
  subMessages?: SubMessageUpdateManyWithoutMessageInput
}

export type OrganizationUpdateWithoutProjectDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutOrganizationInput
  persons?: PersonUpdateManyWithoutOrganizationInput
}

export type OrganizationUpdateManyDataInput = {
  name?: string | StringFieldUpdateOperationsInput
}

export type PersonUpdateWithoutProjectDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  organization?: OrganizationUpdateOneRequiredWithoutPersonsInput
  accounts?: AccountUpdateManyWithoutPersonInput
  contributorAttributeValues?: ContributorAttributeValueUpdateManyWithoutPersonInput
  message_Message_requesterIdToPersons?: MessageUpdateManyWithoutPerson_Message_requesterIdToPersonInput
  message_Message_submitterIdToPersons?: MessageUpdateManyWithoutPerson_Message_submitterIdToPersonInput
  subMessages?: SubMessageUpdateManyWithoutPersonInput
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
