"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeEngine = void 0;
const engines_1 = require("@prisma/engines");
const get_platform_1 = require("@prisma/get-platform");
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("debug"));
const events_1 = __importDefault(require("events"));
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const net_1 = __importDefault(require("net"));
const p_retry_1 = __importDefault(require("p-retry"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const byline_1 = __importDefault(require("./byline"));
const Engine_1 = require("./Engine");
const log_1 = require("./log");
const omit_1 = require("./omit");
const printGeneratorConfig_1 = require("./printGeneratorConfig");
const undici_1 = require("./undici");
const util_2 = require("./util");
const debug = debug_1.default('engine');
const exists = util_1.promisify(fs_1.default.exists);
const readdir = util_1.promisify(fs_1.default.readdir);
/**
 * Node.js based wrapper to run the Prisma binary
 */
const knownPlatforms = [
    'native',
    'darwin',
    'debian-openssl-1.0.x',
    'debian-openssl-1.1.x',
    'rhel-openssl-1.0.x',
    'rhel-openssl-1.1.x',
    'linux-musl',
    'linux-nixos',
    'windows',
    'freebsd11',
    'freebsd12',
    'openbsd',
    'netbsd',
    'arm',
];
const engines = [];
const socketPaths = [];
class NodeEngine {
    constructor({ cwd, datamodelPath, prismaPath, generator, datasources, showColors, logLevel, logQueries, env, flags, clientVersion, enableExperimental, engineEndpoint, enableDebugLogs, enableEngineDebugMode, useUds, }) {
        var _a;
        this.restartCount = 0;
        this.queryEngineStarted = false;
        this.enableExperimental = [];
        this.useUds = false;
        /**
         * exiting is used to tell the .on('exit') hook, if the exit came from our script.
         * As soon as the Prisma binary returns a correct return code (like 1 or 0), we don't need this anymore
         */
        this.queryEngineKilled = false;
        this.managementApiEnabled = false;
        this.ready = false;
        this.stderrLogs = '';
        this.stdoutLogs = '';
        this.handleRequestError = async (error, graceful) => {
            var _a, _b, _c, _d, _e, _f, _g;
            debug({ error });
            let err;
            if (this.currentRequestPromise.isCanceled && this.lastError) {
                // TODO: Replace these errors with known or unknown request errors
                if (this.lastError.is_panic) {
                    err = new Engine_1.PrismaClientRustPanicError(Engine_1.getErrorMessageWithLink({
                        platform: this.platform,
                        title: Engine_1.getMessage(this.lastError),
                        version: this.clientVersion,
                    }), this.clientVersion);
                    this.lastPanic = err;
                }
                else {
                    err = new Engine_1.PrismaClientUnknownRequestError(Engine_1.getErrorMessageWithLink({
                        platform: this.platform,
                        title: Engine_1.getMessage(this.lastError),
                        version: this.clientVersion,
                    }), this.clientVersion);
                }
            }
            else if (this.currentRequestPromise.isCanceled && this.lastErrorLog) {
                if (((_b = (_a = this.lastErrorLog) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.message) === 'PANIC') {
                    err = new Engine_1.PrismaClientRustPanicError(Engine_1.getErrorMessageWithLink({
                        platform: this.platform,
                        title: Engine_1.getMessage(this.lastErrorLog),
                        version: this.clientVersion,
                    }), this.clientVersion);
                    this.lastPanic = err;
                }
                else {
                    err = new Engine_1.PrismaClientUnknownRequestError(Engine_1.getErrorMessageWithLink({
                        platform: this.platform,
                        title: Engine_1.getMessage(this.lastErrorLog),
                        version: this.clientVersion,
                    }), this.clientVersion);
                }
            }
            else if (
            // matching on all relevant error codes from
            // https://github.com/nodejs/undici/blob/2.x/lib/core/errors.js
            error.code === 'ECONNRESET' ||
                error.code === 'ECONNREFUSED' ||
                error.code === 'UND_ERR_CLOSED' ||
                error.code === 'UND_ERR_SOCKET' ||
                error.code === 'UND_ERR_DESTROYED' ||
                error.code === 'UND_ERR_ABORTED' ||
                error.message.toLowerCase().includes('client is destroyed') ||
                error.message.toLowerCase().includes('other side closed')) {
                if (this.globalKillSignalReceived && !this.child.connected) {
                    throw new Engine_1.PrismaClientUnknownRequestError(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
and your request can't be processed.
You probably have some open handle that prevents your process from exiting.
It could be an open http server or stream that didn't close yet.
We recommend using the \`wtfnode\` package to debug open handles.`, this.clientVersion);
                }
                if (this.restartCount > 4) {
                    throw new Error(`Query engine is trying to restart, but can't.
Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
                }
                if (this.lastError) {
                    if (this.lastError.is_panic) {
                        err = new Engine_1.PrismaClientRustPanicError(Engine_1.getErrorMessageWithLink({
                            platform: this.platform,
                            title: Engine_1.getMessage(this.lastError),
                            version: this.clientVersion,
                        }), this.clientVersion);
                        this.lastPanic = err;
                    }
                    else {
                        err = new Engine_1.PrismaClientUnknownRequestError(Engine_1.getErrorMessageWithLink({
                            platform: this.platform,
                            title: Engine_1.getMessage(this.lastError),
                            version: this.clientVersion,
                        }), this.clientVersion);
                    }
                }
                else if (this.lastErrorLog) {
                    if (((_d = (_c = this.lastErrorLog) === null || _c === void 0 ? void 0 : _c.fields) === null || _d === void 0 ? void 0 : _d.message) === 'PANIC') {
                        err = new Engine_1.PrismaClientRustPanicError(Engine_1.getErrorMessageWithLink({
                            platform: this.platform,
                            title: Engine_1.getMessage(this.lastErrorLog),
                            version: this.clientVersion,
                        }), this.clientVersion);
                        this.lastPanic = err;
                    }
                    else {
                        err = new Engine_1.PrismaClientUnknownRequestError(Engine_1.getErrorMessageWithLink({
                            platform: this.platform,
                            title: Engine_1.getMessage(this.lastErrorLog),
                            version: this.clientVersion,
                        }), this.clientVersion);
                    }
                }
                if (!err) {
                    // wait a bit so we get some logs
                    let lastLog = this.getLastLog();
                    if (!lastLog) {
                        await new Promise((r) => setTimeout(r, 500));
                        lastLog = this.getLastLog();
                    }
                    const logs = lastLog || this.stderrLogs || this.stdoutLogs;
                    let title = lastLog !== null && lastLog !== void 0 ? lastLog : error.message;
                    let description = error.stack + '\nExit code: ' + this.exitCode + '\n' + logs;
                    description =
                        `signalCode: ${(_e = this.child) === null || _e === void 0 ? void 0 : _e.signalCode} | exitCode: ${(_f = this.child) === null || _f === void 0 ? void 0 : _f.exitCode} | killed: ${(_g = this.child) === null || _g === void 0 ? void 0 : _g.killed}\n` +
                            description;
                    err = new Engine_1.PrismaClientUnknownRequestError(Engine_1.getErrorMessageWithLink({
                        platform: this.platform,
                        title,
                        version: this.clientVersion,
                        description,
                    }), this.clientVersion);
                    debug(err.message);
                    if (graceful) {
                        return false;
                    }
                }
            }
            if (err) {
                throw err;
            }
            throw error;
        };
        this.env = env;
        this.cwd = this.resolveCwd(cwd);
        this.enableDebugLogs = enableDebugLogs !== null && enableDebugLogs !== void 0 ? enableDebugLogs : false;
        this.enableEngineDebugMode = enableEngineDebugMode !== null && enableEngineDebugMode !== void 0 ? enableEngineDebugMode : false;
        this.datamodelPath = datamodelPath;
        this.prismaPath = (_a = process.env.PRISMA_QUERY_ENGINE_BINARY) !== null && _a !== void 0 ? _a : prismaPath;
        this.generator = generator;
        this.datasources = datasources;
        this.logEmitter = new events_1.default();
        this.showColors = showColors !== null && showColors !== void 0 ? showColors : false;
        this.logLevel = logLevel;
        this.logQueries = logQueries !== null && logQueries !== void 0 ? logQueries : false;
        this.clientVersion = clientVersion;
        this.flags = flags !== null && flags !== void 0 ? flags : [];
        this.enableExperimental = enableExperimental !== null && enableExperimental !== void 0 ? enableExperimental : [];
        const removedFlags = [
            'middlewares',
            'aggregateApi',
            'distinct',
            'aggregations',
            'insensitiveFilters',
            'atomicNumberOperations',
            'transactionApi',
            'transaction',
            'connectOrCreate'
        ];
        const filteredFlags = ['nativeTypes'];
        const removedFlagsUsed = this.enableExperimental.filter((e) => removedFlags.includes(e));
        if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
            console.log(`${chalk_1.default.blueBright('info')} The preview flags \`${removedFlagsUsed.join('`, `')}\` were removed, you can now safely remove them from your schema.prisma.`);
        }
        this.enableExperimental = this.enableExperimental.filter((e) => !removedFlags.includes(e) && !filteredFlags.includes(e));
        this.engineEndpoint = engineEndpoint;
        if (useUds && process.platform !== 'win32') {
            this.socketPath = `/tmp/prisma-${util_2.getRandomString()}.sock`;
            socketPaths.push(this.socketPath);
            this.useUds = useUds;
        }
        if (engineEndpoint) {
            const url = new URL(engineEndpoint);
            this.port = Number(url.port);
        }
        this.logEmitter.on('error', (log) => {
            if (this.enableDebugLogs) {
                debug_1.default('engine:log')(log);
            }
            if (log instanceof Error) {
                debug_1.default('engine:error')(log);
            }
            else {
                this.lastErrorLog = log;
                if (log.fields.message === 'PANIC') {
                    this.handlePanic(log);
                }
            }
        });
        if (this.platform) {
            if (!knownPlatforms.includes(this.platform) &&
                !fs_1.default.existsSync(this.platform)) {
                throw new Engine_1.PrismaClientInitializationError(`Unknown ${chalk_1.default.red('PRISMA_QUERY_ENGINE_BINARY')} ${chalk_1.default.redBright.bold(this.platform)}. Possible binaryTargets: ${chalk_1.default.greenBright(knownPlatforms.join(', '))} or a path to the query engine binary.
You may have to run ${chalk_1.default.greenBright('prisma generate')} for your changes to take effect.`, this.clientVersion);
            }
        }
        else {
            this.getPlatform();
        }
        if (this.enableDebugLogs) {
            debug_1.default.enable('*');
        }
        engines.push(this);
        this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
        if (engines.length >= 10) {
            const runningEngines = engines.filter(e => e.child);
            if (runningEngines.length === 10) {
                console.warn(`${chalk_1.default.yellow('warn(prisma-client)')} Already 10 Prisma Clients are actively running.`);
            }
        }
    }
    resolveCwd(cwd) {
        if (cwd && fs_1.default.existsSync(cwd) && fs_1.default.lstatSync(cwd).isDirectory()) {
            return cwd;
        }
        return process.cwd();
    }
    on(event, listener) {
        if (event === 'beforeExit') {
            this.beforeExitListener = listener;
        }
        else {
            this.logEmitter.on(event, listener);
        }
    }
    async emitExit() {
        if (this.beforeExitListener) {
            try {
                await this.beforeExitListener();
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    async getPlatform() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (this.platformPromise) {
            return this.platformPromise;
        }
        this.platformPromise = get_platform_1.getPlatform();
        return this.platformPromise;
    }
    getQueryEnginePath(platform, prefix = __dirname) {
        let queryEnginePath = path_1.default.join(prefix, `query-engine-${platform}`);
        if (platform === 'windows') {
            queryEnginePath = `${queryEnginePath}.exe`;
        }
        return queryEnginePath;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    handlePanic(log) {
        var _a;
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
        if (this.currentRequestPromise) {
            this.currentRequestPromise.cancel();
        }
    }
    async resolvePrismaPath() {
        var _a, _b;
        const searchedLocations = [];
        let enginePath;
        if (this.prismaPath) {
            return { prismaPath: this.prismaPath, searchedLocations };
        }
        const platform = await this.getPlatform();
        if (this.platform && this.platform !== platform) {
            this.incorrectlyPinnedBinaryTarget = this.platform;
        }
        this.platform = this.platform || platform;
        if (__filename.includes('NodeEngine')) {
            enginePath = this.getQueryEnginePath(this.platform, engines_1.getEnginesPath());
            return { prismaPath: enginePath, searchedLocations };
        }
        const searchLocations = [
            eval(`require('path').join(__dirname, '../../../.prisma/client')`),
            (_b = (_a = this.generator) === null || _a === void 0 ? void 0 : _a.output) !== null && _b !== void 0 ? _b : eval('__dirname'),
            path_1.default.join(eval('__dirname'), '..'),
            path_1.default.dirname(this.datamodelPath),
            this.cwd,
        ];
        for (const location of searchLocations) {
            searchedLocations.push(location);
            debug(`Search for Query Engine in ${location}`);
            enginePath = await this.getQueryEnginePath(this.platform, location);
            if (fs_1.default.existsSync(enginePath)) {
                return { prismaPath: enginePath, searchedLocations };
            }
        }
        enginePath = await this.getQueryEnginePath(this.platform);
        return { prismaPath: enginePath !== null && enginePath !== void 0 ? enginePath : '', searchedLocations };
    }
    // get prisma path
    async getPrismaPath() {
        const { prismaPath, searchedLocations } = await this.resolvePrismaPath();
        const platform = await this.getPlatform();
        // If path to query engine doesn't exist, throw
        if (!(await exists(prismaPath))) {
            const pinnedStr = this.incorrectlyPinnedBinaryTarget
                ? `\nYou incorrectly pinned it to ${chalk_1.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}\n`
                : '';
            let errorText = `Query engine binary for current platform "${chalk_1.default.bold(platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${chalk_1.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations.map((f) => `  ${f}`).join('\n')}\n`;
            // The generator should always be there during normal usage
            if (this.generator) {
                // The user already added it, but it still doesn't work ðŸ¤·â€â™€ï¸
                // That means, that some build system just deleted the files ðŸ¤”
                if (this.generator.binaryTargets.includes(this.platform) ||
                    this.generator.binaryTargets.includes('native')) {
                    errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? 's' : ''} ${this.generator.binaryTargets
                        .map((t) => `"${chalk_1.default.bold(t)}"`)
                        .join(', ')} to the "${chalk_1.default.underline('generator')}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma-client-js/issues/new`;
                    errorText += ``;
                }
                else {
                    // If they didn't even have the current running platform in the schema.prisma file, it's easy
                    // Just add it
                    errorText += `\n\nTo solve this problem, add the platform "${this.platform}" to the "${chalk_1.default.underline('generator')}" block in the "schema.prisma" file:
${chalk_1.default.greenBright(this.getFixedGenerator())}

Then run "${chalk_1.default.greenBright('prisma generate')}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
                }
            }
            else {
                errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;
            }
            throw new Engine_1.PrismaClientInitializationError(errorText, this.clientVersion);
        }
        if (this.incorrectlyPinnedBinaryTarget) {
            console.error(`${chalk_1.default.yellow('Warning:')} You pinned the platform ${chalk_1.default.bold(this.incorrectlyPinnedBinaryTarget)}, but Prisma Client detects ${chalk_1.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${chalk_1.default.greenBright(await this.getPlatform())} instead.
${chalk_1.default.dim("In case we're mistaken, please report this to us ðŸ™.")}`);
        }
        if (process.platform !== 'win32') {
            util_2.plusX(prismaPath);
        }
        return prismaPath;
    }
    getFixedGenerator() {
        const fixedGenerator = {
            ...this.generator,
            binaryTargets: util_2.fixBinaryTargets(this.generator.binaryTargets, this.platform),
        };
        return printGeneratorConfig_1.printGeneratorConfig(fixedGenerator);
    }
    printDatasources() {
        if (this.datasources) {
            return JSON.stringify(this.datasources);
        }
        return '[]';
    }
    /**
     * Starts the engine, returns the url that it runs on
     */
    async start() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (!this.startPromise) {
            this.startPromise = this.internalStart();
        }
        return this.startPromise;
    }
    async getEngineEnvVars() {
        const env = {
            PRISMA_DML_PATH: this.datamodelPath,
            RUST_BACKTRACE: '1',
            RUST_LOG: 'info',
        };
        if (!this.useUds) {
            env.PORT = String(this.port);
            debug(`port: ${this.port}`);
        }
        if (this.logQueries || this.logLevel === 'info') {
            env.RUST_LOG = 'info';
            if (this.logQueries) {
                env.LOG_QUERIES = 'true';
            }
        }
        if (this.datasources) {
            env.OVERWRITE_DATASOURCES = this.printDatasources();
        }
        if (!process.env.NO_COLOR && this.showColors) {
            env.CLICOLOR_FORCE = '1';
        }
        return {
            ...this.env,
            ...process.env,
            ...env,
        };
    }
    internalStart() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            var _a, _b, _c;
            await new Promise((r) => process.nextTick(r));
            if (this.stopPromise) {
                await this.stopPromise;
            }
            if (this.engineEndpoint) {
                try {
                    await p_retry_1.default(() => this.undici.status(), {
                        retries: 10,
                    });
                }
                catch (e) {
                    return reject(e);
                }
                return resolve();
            }
            try {
                if (((_a = this.child) === null || _a === void 0 ? void 0 : _a.connected) || (this.child && !((_b = this.child) === null || _b === void 0 ? void 0 : _b.killed))) {
                    debug(`There is a child that still runs and we want to start again`);
                }
                this.queryEngineStarted = false;
                // reset last panic
                this.lastError = undefined;
                this.lastErrorLog = undefined;
                this.lastPanic = undefined;
                this.queryEngineKilled = false;
                this.globalKillSignalReceived = undefined;
                debug({ cwd: this.cwd });
                const prismaPath = await this.getPrismaPath();
                const experimentalFlags = this.enableExperimental &&
                    Array.isArray(this.enableExperimental) &&
                    this.enableExperimental.length > 0
                    ? [`--enable-experimental=${this.enableExperimental.join(',')}`]
                    : [];
                const debugFlag = this.enableEngineDebugMode ? ['--debug'] : [];
                const flags = [
                    ...experimentalFlags,
                    ...debugFlag,
                    '--enable-raw-queries',
                    ...this.flags,
                ];
                if (this.useUds) {
                    flags.push('--unix-path', this.socketPath);
                }
                debug({ flags });
                this.port = await this.getFreePort();
                const env = await this.getEngineEnvVars();
                this.child = child_process_1.spawn(prismaPath, flags, {
                    env,
                    cwd: this.cwd,
                    windowsHide: true,
                    stdio: ['ignore', 'pipe', 'pipe'],
                });
                byline_1.default(this.child.stderr).on('data', (msg) => {
                    const data = String(msg);
                    debug('stderr', data);
                    try {
                        const json = JSON.parse(data);
                        if (typeof json.is_panic !== 'undefined') {
                            debug(json);
                            this.lastError = json;
                            if (this.engineStartDeferred) {
                                const err = new Engine_1.PrismaClientInitializationError(this.lastError.message, this.clientVersion);
                                this.engineStartDeferred.reject(err);
                            }
                        }
                    }
                    catch (e) {
                        if (!data.includes('Printing to stderr') &&
                            !data.includes('Listening on ')) {
                            this.stderrLogs += '\n' + data;
                        }
                    }
                });
                byline_1.default(this.child.stdout).on('data', (msg) => {
                    var _a;
                    const data = String(msg);
                    try {
                        const json = JSON.parse(data);
                        debug('stdout', json);
                        if (this.engineStartDeferred &&
                            json.level === 'INFO' &&
                            json.target === 'query_engine::server' && ((_a = json.fields) === null || _a === void 0 ? void 0 : _a.message.startsWith('Started http server'))) {
                            if (this.useUds) {
                                this.undici = new undici_1.Undici({
                                    hostname: 'localhost',
                                    protocol: 'http:',
                                }, {
                                    socketPath: this.socketPath,
                                });
                            }
                            else {
                                this.undici = new undici_1.Undici(`http://localhost:${this.port}`);
                            }
                            this.engineStartDeferred.resolve();
                            this.engineStartDeferred = undefined;
                            this.queryEngineStarted = true;
                        }
                        if (typeof json.is_panic === 'undefined') {
                            const log = log_1.convertLog(json);
                            this.logEmitter.emit(log.level, log);
                            this.lastLog = log;
                        }
                        else {
                            this.lastError = json;
                        }
                    }
                    catch (e) {
                        debug(e, data);
                    }
                });
                this.child.on('exit', (code) => {
                    var _a, _b;
                    if (this.engineStopDeferred) {
                        this.engineStopDeferred.resolve(code);
                        return;
                    }
                    (_a = this.undici) === null || _a === void 0 ? void 0 : _a.close();
                    this.exitCode = code;
                    if (!this.queryEngineKilled &&
                        this.queryEngineStarted &&
                        this.restartCount < 5) {
                        p_retry_1.default(async (attempt) => {
                            debug(`Restart attempt ${attempt}. Waiting for backoff`);
                            if (this.backoffPromise) {
                                await this.backoffPromise;
                            }
                            debug(`Restart attempt ${attempt}. Backoff done`);
                            this.restartCount++;
                            //  TODO: look into this
                            const wait = Math.random() * 2 * Math.pow(Math.E, this.restartCount);
                            this.startPromise = undefined;
                            this.backoffPromise = new Promise((r) => setTimeout(r, wait));
                            return this.start();
                        }, {
                            retries: 4,
                            randomize: true,
                            minTimeout: 1000,
                            maxTimeout: 60 * 1000,
                            factor: Math.E,
                            onFailedAttempt: (e) => {
                                debug(e);
                            },
                        });
                        return;
                    }
                    if (code !== 0 && this.engineStartDeferred) {
                        let err;
                        if (code !== null) {
                            err = new Engine_1.PrismaClientInitializationError(`Query engine exited with code ${code}\n` + this.stderrLogs, this.clientVersion);
                        }
                        else if ((_b = this.child) === null || _b === void 0 ? void 0 : _b.signalCode) {
                            err = new Engine_1.PrismaClientInitializationError(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.\n` +
                                this.stderrLogs, this.clientVersion);
                        }
                        else {
                            err = new Engine_1.PrismaClientInitializationError(this.stderrLogs, this.clientVersion);
                        }
                        this.engineStartDeferred.reject(err);
                    }
                    if (!this.child) {
                        return;
                    }
                    if (this.lastError) {
                        return;
                    }
                    if (this.lastErrorLog) {
                        this.lastErrorLog.target = 'exit';
                        return;
                    }
                    if (code === 126) {
                        this.lastErrorLog = {
                            timestamp: new Date(),
                            target: 'exit',
                            level: 'error',
                            fields: {
                                message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`,
                            },
                        };
                    }
                    else {
                        this.lastErrorLog = {
                            target: 'exit',
                            timestamp: new Date(),
                            level: 'error',
                            fields: {
                                message: (this.stderrLogs || '') +
                                    (this.stdoutLogs || '') +
                                    `\nExit code: ${code}`,
                            },
                        };
                    }
                });
                this.child.on('error', (err) => {
                    this.lastError = {
                        message: err.message,
                        backtrace: 'Could not start query engine',
                        is_panic: false,
                    };
                    reject(err);
                });
                this.child.on('close', (code, signal) => {
                    var _a, _b;
                    (_a = this.undici) === null || _a === void 0 ? void 0 : _a.close();
                    if (code === null && signal === 'SIGABRT' && this.child) {
                        const error = new Engine_1.PrismaClientRustPanicError(Engine_1.getErrorMessageWithLink({
                            platform: this.platform,
                            title: `Panic in Query Engine with SIGABRT signal`,
                            description: this.stderrLogs,
                            version: this.clientVersion,
                        }), this.clientVersion);
                        this.logEmitter.emit('error', error);
                    }
                    else if (code === 255 &&
                        signal === null &&
                        // if there is a "this.lastPanic", the panic has already been handled, so we don't need
                        // to look into it anymore
                        ((_b = this.lastErrorLog) === null || _b === void 0 ? void 0 : _b.fields.message) === 'PANIC' &&
                        !this.lastPanic) {
                        const error = new Engine_1.PrismaClientRustPanicError(Engine_1.getErrorMessageWithLink({
                            platform: this.platform,
                            title: `${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in
${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`,
                            version: this.clientVersion,
                        }), this.clientVersion);
                        this.logEmitter.emit('error', error);
                    }
                });
                if (this.lastError) {
                    return reject(new Engine_1.PrismaClientInitializationError(Engine_1.getMessage(this.lastError), this.clientVersion));
                }
                if (this.lastErrorLog) {
                    return reject(new Engine_1.PrismaClientInitializationError(Engine_1.getMessage(this.lastErrorLog), this.clientVersion));
                }
                try {
                    await new Promise((resolve, reject) => {
                        this.engineStartDeferred = { resolve, reject };
                    });
                }
                catch (err) {
                    (_c = this.child) === null || _c === void 0 ? void 0 : _c.kill();
                    throw err;
                }
                this.url = `http://localhost:${this.port}`;
                (async () => {
                    const engineVersion = await this.version();
                    debug(`Client Version ${this.clientVersion}`);
                    debug(`Engine Version ${engineVersion}`);
                })();
                this.stopPromise = undefined;
                resolve();
            }
            catch (e) {
                reject(e);
            }
        });
    }
    async stop() {
        if (!this.stopPromise) {
            this.stopPromise = this._stop();
        }
        return this.stopPromise;
    }
    /**
     * If Prisma runs, stop it
     */
    async _stop() {
        var _a, _b;
        if (this.startPromise) {
            await this.startPromise;
        }
        // not sure yet if this is a good idea
        await new Promise((resolve) => process.nextTick(resolve));
        if (this.currentRequestPromise) {
            try {
                await this.currentRequestPromise;
            }
            catch (e) {
                //
            }
        }
        this.getConfigPromise = undefined;
        let stopChildPromise;
        if (this.child) {
            debug(`Stopping Prisma engine4`);
            if (this.startPromise) {
                debug(`Waiting for start promise`);
                await this.startPromise;
            }
            debug(`Done waiting for start promise`);
            stopChildPromise = new Promise((resolve, reject) => {
                this.engineStopDeferred = { resolve, reject };
            });
            this.queryEngineKilled = true;
            (_a = this.undici) === null || _a === void 0 ? void 0 : _a.close();
            (_b = this.child) === null || _b === void 0 ? void 0 : _b.kill();
            this.child = undefined;
        }
        if (stopChildPromise) {
            await stopChildPromise;
        }
        await new Promise((r) => process.nextTick(r));
        this.startPromise = undefined;
        this.engineStopDeferred = undefined;
        setTimeout(() => {
            if (this.socketPath) {
                try {
                    fs_1.default.unlinkSync(this.socketPath);
                }
                catch (e) {
                    debug(e);
                    //
                }
                socketPaths.splice(socketPaths.indexOf(this.socketPath), 1);
                this.socketPath = undefined;
            }
        });
    }
    async kill(signal) {
        var _a, _b;
        this.getConfigPromise = undefined;
        this.globalKillSignalReceived = signal;
        this.queryEngineKilled = true;
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
        (_b = this.undici) === null || _b === void 0 ? void 0 : _b.close();
    }
    /**
     * Use the port 0 trick to get a new port
     */
    getFreePort() {
        return new Promise((resolve, reject) => {
            const server = net_1.default.createServer((s) => s.end(''));
            server.unref();
            server.on('error', reject);
            server.listen(0, () => {
                const address = server.address();
                const port = typeof address === 'string'
                    ? parseInt(address.split(':').slice(-1)[0], 10)
                    : address.port;
                server.close((e) => {
                    if (e) {
                        reject(e);
                    }
                    resolve(port);
                });
            });
        });
    }
    async getConfig() {
        if (!this.getConfigPromise) {
            this.getConfigPromise = this._getConfig();
        }
        return this.getConfigPromise;
    }
    async _getConfig() {
        const prismaPath = await this.getPrismaPath();
        const env = await this.getEngineEnvVars();
        const result = await execa_1.default(prismaPath, ['cli', 'get-config'], {
            env: omit_1.omit(env, ['PORT']),
            cwd: this.cwd,
        });
        return JSON.parse(result.stdout);
    }
    async version() {
        const prismaPath = await this.getPrismaPath();
        const result = await execa_1.default(prismaPath, ['--version'], {
            env: {
                ...process.env,
            },
        });
        return result.stdout;
    }
    async request(query, headers, numTry = 1) {
        if (this.stopPromise) {
            await this.stopPromise;
        }
        await this.start();
        if (!this.child && !this.engineEndpoint) {
            throw new Engine_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
        }
        this.currentRequestPromise = this.undici.request(stringifyQuery(query), headers);
        return this.currentRequestPromise
            .then(({ data, headers }) => {
            if (data.errors) {
                if (data.errors.length === 1) {
                    throw this.graphQLToJSError(data.errors[0]);
                }
                // this case should not happen, as the query engine only returns one error
                throw new Error(JSON.stringify(data.errors));
            }
            // Rust engine returns time in microseconds and we want it in miliseconds
            const elapsed = parseInt(headers['x-elapsed']) / 1000;
            // reset restart count after successful request
            if (this.restartCount > 0) {
                this.restartCount = 0;
            }
            return { data, elapsed };
        })
            .catch(async (e) => {
            const isError = await this.handleRequestError(e, numTry < 3);
            if (!isError) {
                // retry
                if (numTry < 3) {
                    await new Promise((r) => setTimeout(r, Math.random() * 1000));
                    return this.request(query, headers, numTry + 1);
                }
            }
            throw isError;
        });
    }
    async requestBatch(queries, transaction = false, numTry = 1) {
        await this.start();
        if (!this.child && !this.engineEndpoint) {
            throw new Engine_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
        }
        const variables = {};
        const body = {
            batch: queries.map((query) => ({ query, variables })),
            transaction,
        };
        this.currentRequestPromise = this.undici.request(JSON.stringify(body));
        return this.currentRequestPromise
            .then(({ data, headers }) => {
            // Rust engine returns time in microseconds and we want it in miliseconds
            const elapsed = parseInt(headers['x-elapsed']) / 1000;
            if (Array.isArray(data)) {
                return data.map((result) => {
                    if (result.errors) {
                        return this.graphQLToJSError(result.errors[0]);
                    }
                    return {
                        data: result,
                        elapsed,
                    };
                });
            }
            else {
                if (data.errors && data.errors.length === 1) {
                    throw new Error(data.errors[0].error);
                }
                throw new Error(JSON.stringify(data));
            }
        })
            .catch(async (e) => {
            const isError = await this.handleRequestError(e, numTry < 3);
            if (!isError) {
                // retry
                if (numTry < 3) {
                    await new Promise((r) => setTimeout(r, Math.random() * 1000));
                    return this.requestBatch(queries, transaction, numTry + 1);
                }
            }
            throw isError;
        });
    }
    getLastLog() {
        var _a, _b, _c;
        const message = (_b = (_a = this.lastLog) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.message;
        if (message) {
            const fields = Object.entries((_c = this.lastLog) === null || _c === void 0 ? void 0 : _c.fields)
                .filter(([key]) => key !== 'message')
                .map(([key, value]) => {
                return `${key}: ${value}`;
            })
                .join(', ');
            if (fields) {
                return `${message}  ${fields}`;
            }
            return message;
        }
        return null;
    }
    graphQLToJSError(error) {
        if (error.user_facing_error.error_code) {
            return new Engine_1.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.clientVersion, error.user_facing_error.meta);
        }
        return new Engine_1.PrismaClientUnknownRequestError(error.user_facing_error.message, this.clientVersion);
    }
}
exports.NodeEngine = NodeEngine;
// faster than creating a new object and JSON.stringify it all the time
function stringifyQuery(q) {
    return `{"variables":{},"query":${JSON.stringify(q)}}`;
}
function hookProcess(handler, exit = false) {
    process.once(handler, async () => {
        for (const engine of engines) {
            await engine.emitExit();
            engine.kill(handler);
        }
        engines.splice(0, engines.length);
        if (socketPaths.length > 0) {
            for (const socketPath of socketPaths) {
                try {
                    fs_1.default.unlinkSync(socketPath);
                }
                catch (e) {
                    //
                }
            }
        }
        // only exit, if only we are listening
        // if there is another listener, that other listener is responsible
        if (exit && process.listenerCount(handler) === 0) {
            process.exit();
        }
    });
}
hookProcess('beforeExit');
hookProcess('exit');
hookProcess('SIGINT', true);
hookProcess('SIGUSR1', true);
hookProcess('SIGUSR2', true);
hookProcess('SIGTERM', true);
//# sourceMappingURL=NodeEngine.js.map