"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
let RESERVED = ["PrismaClient", "Prisma"];
function isPrismaImport(value) {
    const prismaPaths = [".prisma/client", "@prisma/client"];
    if (process.env.PRISMA_CUSTOM_IMPORT_PATH) {
        prismaPaths.push(process.env.PRISMA_CUSTOM_IMPORT_PATH);
    }
    return prismaPaths.some((p) => {
        return value.includes(p);
    });
}
function handleImports(root, j) {
    let edit = [];
    let shouldAddImport = true;
    const prismaImport = root.find(j.ImportDeclaration).filter((nodePath) => {
        return (Boolean(nodePath.node.source.value) &&
            typeof nodePath.node.source.value === "string" &&
            isPrismaImport(nodePath.node.source.value));
    });
    const specifiers = prismaImport
        .find(j.ImportSpecifier)
        .filter((nPath) => {
        if (nPath.value.local && nPath.value.local.name === "Prisma") {
            shouldAddImport = false;
        }
        if (nPath.value.local && !RESERVED.includes(nPath.value.local.name) && nPath.value.local.name === nPath.value.imported.name) {
            edit.push(nPath.value.local.name);
            return true;
        }
        return false;
    })
        .remove();
    if (edit.length > 0 && shouldAddImport) {
        specifiers.at(0).insertBefore(j.importSpecifier(j.identifier("Prisma")));
    }
    return edit;
}
function handleRequire(root, j) {
    let edit = [];
    let shouldAddImport = true;
    // console.log("Running");
    root
        .find(j.VariableDeclarator)
        .filter((vdPath) => {
        // console.log(vdPath);
        if (vdPath.node.id.type === "ObjectPattern" &&
            vdPath.node.init &&
            vdPath.node.init.type === "CallExpression") {
            if (vdPath.node.init.callee.type === "Identifier" &&
                vdPath.node.init.callee.name === "require") {
                if (vdPath.node.init.arguments) {
                    // console.log(vdPath.node.init.arguments[0].type === "StringLiteral");
                    return true;
                }
            }
        }
        return false;
    })
        .forEach((path) => {
        const value = path.node.init
            .arguments[0].value;
        if (isPrismaImport(value)) {
            let variableDeclarator = j(path);
            // console.log(path.node.id);
            const properties = variableDeclarator
                .find(j.ObjectProperty)
                .filter((propertyPath) => {
                // , { key: { type: "Identifier" } }
                // console.log(propertyPath.node);
                return propertyPath.node.key.type === "Identifier";
            })
                .forEach((property) => {
                if (property.value.key.name === "Prisma") {
                    shouldAddImport = false;
                }
                // console.log(property);
                if (!RESERVED.includes(property.value.key.name)) {
                    edit.push(property.value.key.name);
                    j(property).remove();
                }
            });
            if (edit.length > 0 && shouldAddImport) {
                properties.at(0).insertBefore(j.identifier("Prisma"));
            }
        }
    });
    return edit;
}
function transform(file, api, options) {
    if (process.env.PRISMA_TOP_LEVEL_EXPORTS_FILE) {
        const data = fs_1.default.readFileSync(process.env.PRISMA_TOP_LEVEL_EXPORTS_FILE, { encoding: 'utf8' });
        const topLevelExports = data.split(',');
        RESERVED.push(...topLevelExports);
        RESERVED = RESERVED.filter((v, i, a) => a.indexOf(v) === i);
    }
    const j = api.jscodeshift;
    // Convert the entire file source into a collection of nodes paths.
    const root = j(file.source);
    const importEdits = handleImports(root, j);
    const requireEdits = handleRequire(root, j);
    const all = importEdits.concat(requireEdits);
    const edit = all.filter(function (elem, pos) {
        return all.indexOf(elem) == pos;
    });
    const identifiers = root.find(j.Identifier);
    identifiers
        .filter((idPath) => {
        return edit.includes(idPath.value.name) && idPath.parent.value.type !== 'ImportSpecifier';
    })
        .replaceWith((p) => Object.assign({}, p.node, {
        name: `Prisma.${p.node.name}`,
    }));
    return root.toSource();
}
exports.default = transform;
//# sourceMappingURL=namespace.js.map